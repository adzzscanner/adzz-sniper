<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>Adzz Sniper â€” 27 Coins</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { 
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', monospace; 
  background: #0b0b16; 
  color: #0af; 
  padding: 8px; 
  line-height: 1.4; 
  overflow-x: hidden;
}
h1 { 
  color: #0f0; 
  text-align: center; 
  font-size: 1.25em; 
  margin: 6px 0;
}
.container { max-width: 100%; margin: 0 auto; padding: 0 4px; }
.status { 
  background: #1a1a2e; 
  padding: 8px; 
  border-radius: 6px; 
  text-align: center; 
  margin: 10px 0; 
  font-size: 0.95em;
  color: #ffaa00;
}
.section { 
  background: #16213e; 
  padding: 10px; 
  margin: 10px 0; 
  border-radius: 6px; 
  font-size: 0.95em;
}
.chaos { border-left: 4px solid #ff5555; }
.flash { border-left: 4px solid #ffaa00; }
.coin-row { 
  padding: 10px; 
  margin: 6px 0; 
  background: #0d0d1a; 
  border-radius: 6px; 
  font-size: 1.15em; 
  word-break: break-all;
}
.tp-levels { font-size: 1.05em; color: #88f; margin-top: 4px; }
.tp-main { color: #0f0; font-weight: bold; }
.high-conviction { color: #ffff00; font-weight: bold; }
.volatility-score { font-size: 0.85em; color: #aaa; margin-top: 4px; }
.button-container { text-align: center; margin: 15px 0; }
button { 
  padding: 12px 24px; 
  background: #0f0; 
  color: #000; 
  border: none; 
  font-weight: bold; 
  border-radius: 6px; 
  font-size: 1.1em; 
  cursor: pointer; 
  width: 100%;
  max-width: 300px;
  margin: 0 auto;
}
.manual-note { 
  background: #2a0a3a; 
  padding: 10px; 
  border-left: 4px solid #ff55ff; 
  margin: 15px 0; 
  font-size: 0.95em; 
  text-align: center;
  border-radius: 6px;
}
</style>
</head>
<body>
<div class="container">
  <h1>Adzz Sniper â€” 27 Coins</h1>
  <div class="status" id="status">Tap "SCAN" to find 10â€“15% setups</div>

  <div class="manual-note">
    ðŸŽ¯ 27 HIGH-CONVICTION COINS â€¢ MIN 10% TP â€¢ BTC MUST BE CALM
  </div>

  <div class="section chaos">
    <h3>ðŸ”´ CHAOS: 30â€“70% dips</h3>
    <p style="font-size:0.85em;color:#888;margin:6px 0;">Volume â‰¥1.3x â€¢ 15% TP</p>
    <div id="chaosOutput">No setups</div>
  </div>

  <div class="section flash">
    <h3>ðŸŸ  FLASH: 10â€“30% dips</h3>
    <p style="font-size:0.85em;color:#888;margin:6px 0;">Volume â‰¥1.5x â€¢ BTC 2â€“6% â€¢ 15% TP</p>
    <div id="flashOutput">No setups</div>
  </div>

  <div class="button-container">
    <button onclick="startScan()">SCAN</button>
  </div>
</div>

<script>
// âœ… YOUR FINAL 27-COIN UNIVERSE
const COINS = [
  // ðŸ”¥ Pure Flash / Explosive
  "JUP","PYTH","PIXEL","TNSR","STG",
  "HOOK","MAGIC","ZRO","PORTAL","NIL","ONDO","W",
  // âš¡ High-Speed Momentum
  "INJ","TAO","FET","RENDER","SEI","SUI","APT","ARB","OP","IMX",
  "TIA","NEAR","MATIC","LINK","RNDR"
];

const BASE_URL = "https://api.binance.com/api/v3";

// Fetch with retry
async function fetchWithRetry(url, retries = 2, timeoutMs = 8000) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch(url, { signal: controller.signal });
    clearTimeout(timeout);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  } catch (e) {
    clearTimeout(timeout);
    if (retries > 0) {
      await new Promise(r => setTimeout(r, 500));
      return fetchWithRetry(url, retries - 1, timeoutMs);
    }
    return null;
  }
}

async function fetchKlines(symbol, interval, limit) {
  return await fetchWithRetry(`${BASE_URL}/klines?symbol=${symbol}USDT&interval=${interval}&limit=${limit}`);
}

// BTC Ranges
async function getBTCRange(interval, limit) {
  const klines = await fetchKlines("BTC", interval, limit);
  if (!klines || klines.length === 0) return 0;
  const highs = klines.map(k => parseFloat(k[2]));
  const lows = klines.map(k => parseFloat(k[3]));
  const high = Math.max(...highs);
  const low = Math.min(...lows);
  return ((high - low) / low) * 100;
}

// Core logic
function calculateVolatilityScore(drop, volSpike, price, mode = 'normal') {
  let priceMultiplier = 1.0;
  if (price < 0.5) priceMultiplier = 1.8;
  else if (price < 1.0) priceMultiplier = 1.5;
  else if (price < 2.0) priceMultiplier = 1.2;
  else if (price > 5.0) priceMultiplier = 0.7;
  const clampedVolSpike = Math.min(volSpike, 3.0);
  const modeBonus = mode === 'chaos' ? 1.3 : 1.15;
  return drop * clampedVolSpike * priceMultiplier * modeBonus;
}

function calculateEMA(prices, period) {
  const k = 2 / (period + 1);
  let ema = prices[0];
  for (let i = 1; i < prices.length; i++) {
    ema = prices[i]*k + ema*(1-k);
  }
  return ema;
}

function isNearLow(lows, price, pct=2) {
  const minLow = Math.min(...lows);
  return price <= minLow*(1 + pct/100);
}

function calculateDrop(highs, currentPrice) {
  const recentHigh = Math.max(...highs);
  return recentHigh>0 ? ((recentHigh-currentPrice)/recentHigh)*100 : 0;
}

// Render with full detail
function renderCoinRow(data) {
  const { coin, zone, price, tp, highConv, volatilityScore } = data;
  const entryLow = (price * 0.99).toFixed(4);
  const entryHigh = (price * 1.01).toFixed(4);
  const icons = { Flash: 'ðŸŸ ', Chaos: 'ðŸ”´' };
  const badge = highConv ? ' <span class="high-conviction">ðŸ”¥</span>' : '';
  const speedBadge = volatilityScore >= 50 ? ' âš¡' : '';

  return `
    <div class="coin-row">
      ${icons[zone]} ${coin}${badge}${speedBadge} â€” $${price.toFixed(4)}<br>
      <span class="tp-levels">Entry: $${entryLow} â€“ $${entryHigh} | TP <span class="tp-main">$${tp.toFixed(4)}</span></span>
      <div class="volatility-score">Volatility: ${volatilityScore.toFixed(1)}</div>
    </div>
  `;
}

// Core scan
async function detectZone(coin, btc24hRange) {
  // ðŸ”´ CHAOS: 4h
  const k4h = await fetchKlines(coin, '4h', 50);
  if (k4h && k4h.length >= 50) {
    const highs = k4h.map(k=>parseFloat(k[2]));
    const lows = k4h.map(k=>parseFloat(k[3]));
    const closes = k4h.map(k=>parseFloat(k[4]));
    const vols = k4h.map(k=>parseFloat(k[5]));
    const price = closes[closes.length-1];
    const drop = calculateDrop(highs, price);
    
    if (drop >= 30 && drop <= 70) {
      const lastHigh = parseFloat(k4h[k4h.length-1][2]);
      const lastLow = parseFloat(k4h[k4h.length-1][3]);
      if ((lastHigh - lastLow) / price < 0.015) return null;

      const ema7 = calculateEMA(closes.slice(-7), 7);
      const ema25 = calculateEMA(closes.slice(-25), 25);
      const nearLow = isNearLow(lows.slice(-10), price, 2);
      const volAvg20 = vols.slice(-21,-1).reduce((a,b)=>a+b,0)/20;
      const volRatio = volAvg20 > 0 ? vols[vols.length-1] / volAvg20 : 0;
      
      if (ema7 < ema25 && nearLow && volRatio >= 1.3) {
        const volatilityScore = calculateVolatilityScore(drop, volRatio, price, 'chaos');
        return { zone: 'Chaos', coin, price, tp: price * 1.15, highConv: true, volatilityScore };
      }
    }
  }

  // ðŸŸ  FLASH: 1h
  const k1h = await fetchKlines(coin, '1h', 25);
  if (k1h && k1h.length >= 25) {
    const highs = k1h.map(k=>parseFloat(k[2]));
    const lows = k1h.map(k=>parseFloat(k[3]));
    const closes = k1h.map(k=>parseFloat(k[4]));
    const vols = k1h.map(k=>parseFloat(k[5]));
    const price = closes[closes.length-1];
    const drop = calculateDrop(highs, price);
    const ema7 = calculateEMA(closes.slice(-7), 7);
    const ema25 = calculateEMA(closes.slice(-25), 25);
    const vol24 = vols.slice(-24).reduce((a,b)=>a+b,0);
    const volAvg24 = vols.slice(-25,-1).reduce((a,b)=>a+b,0)/24;
    const volSpike = volAvg24 > 0 ? vols[vols.length-1] / volAvg24 : 0;
    const nearLow = isNearLow(lows.slice(-6), price, 4);

    const lastHigh = parseFloat(k1h[k1h.length-1][2]);
    const lastLow = parseFloat(k1h[k1h.length-1][3]);
    if ((lastHigh - lastLow) / price < 0.015) return null;

    if (drop >= 10 && drop < 30 && vol24 > 2_000_000 && volSpike >= 1.5 && ema7 <= ema25 * 1.01 && nearLow) {
      if (btc24hRange >= 2 && btc24hRange <= 6) {
        const volatilityScore = calculateVolatilityScore(drop, volSpike, price, 'flash');
        return { zone: 'Flash', coin, price, tp: price * 1.15, highConv: true, volatilityScore };
      }
    }
  }

  return null;
}

// Render
function renderZoneSection(zoneId, results) {
  const outputEl = document.getElementById(`${zoneId}Output`);
  if (results.length > 0) {
    results.sort((a,b) => b.volatilityScore - a.volatilityScore);
    const displayed = zoneId === 'chaos' ? results.slice(0,1) : results.slice(0,2);
    outputEl.innerHTML = displayed.map(renderCoinRow).join('');
  } else {
    outputEl.innerHTML = `<div class="status">No setups</div>`;
  }
}

// ðŸš¨ MAIN SCAN
async function startScan() {
  const status = document.getElementById('status');
  status.innerHTML = "ðŸ”„ Checking BTC regime...";

  const [btc48h, btc24h] = await Promise.all([
    getBTCRange('4h', 25),
    getBTCRange('1h', 25)
  ]);

  const btcStable = btc48h < 8;
  const flashSafe = btcStable && btc24h >= 2 && btc24h <= 6;
  const flashText = flashSafe ? 'ðŸŸ¢ Flash-Safe' : 'âšª Flash-Locked';

  if (!btcStable) {
    status.innerHTML = `<span style="color:#ff5555;font-weight:bold;">ðŸ”´ BTC volatile â€” NO TRADE</span>`;
    document.getElementById('chaosOutput').innerHTML = '<div class="status">Market not tradeable</div>';
    document.getElementById('flashOutput').innerHTML = '<div class="status">Market not tradeable</div>';
    return;
  }

  status.innerHTML = `ðŸŸ¢ BTC: ${btc48h.toFixed(1)}% â€¢ ${flashText}<br>Scanning 27 coins...`;

  const chaosResults = [];
  const flashResults = [];

  for (let i = 0; i < COINS.length; i++) {
    const coin = COINS[i];
    status.innerHTML = `ðŸŸ¢ BTC: ${btc48h.toFixed(1)}% â€¢ ${flashText}<br>Scanning ${coin}...`;
    const signal = await detectZone(coin, btc24h);
    if (signal) {
      if (signal.zone === 'Chaos') chaosResults.push(signal);
      else if (signal.zone === 'Flash') flashResults.push(signal);
    }
    if (i % 5 === 0) await new Promise(r => setTimeout(r, 100));
  }

  renderZoneSection('chaos', chaosResults);
  renderZoneSection('flash', flashResults);

  const total = chaosResults.length + flashResults.length;
  status.innerHTML = `ðŸŸ¢ BTC: ${btc48h.toFixed(1)}% â€¢ ${flashText}<br><strong>${total} setup${total !== 1 ? 's' : ''} ready</strong>`;
}
</script>
</body>
</html>
