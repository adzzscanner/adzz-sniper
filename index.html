<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>üöÄ FLASH SCANNER v11.4 ‚Äî AUTO-TRAIL + DIP/CONT</title>
<style>
body { font-family: monospace; background:#0f0f15; color:#eee; padding:20px; }
.signal { margin:12px 0; padding:12px; border-radius:6px; }
.flash { background:#2a1a3a; border-left:4px solid #ff6b6b; }
.normal { background:#1a2a2a; border-left:4px solid #4ecdc4; }
.momentum { background:#3a1a5a; border-left:4px solid #a678ff; }
.chaos { background:#1a0f1a; border-left:4px solid #ffcc00; }
.rank { color:#ffcc00; font-weight:bold; }
button { background:#222; color:#ffcc00; border:1px solid #444; padding:10px 16px; margin-right:6px; cursor:pointer; font-weight:bold; }
.stats { background:#1a2a2a; padding:15px; border-radius:8px; margin:10px 0; }
</style>
</head>
<body>

<h2>üöÄ FLASH SCANNER v11.4 ‚Äî AUTO-TRAIL + DIP/CONT</h2>

<button onclick="runScan()">üîç RUN SCAN</button>
<button onclick="toggleMode()" id="modeBtn">üìâ Mode: DIP</button>
<button onclick="clearCache()">üßπ CLEAR CACHE</button>

<div id="btcGateStatus" class="stats"></div>
<div id="scanStats" class="stats"></div>
<div id="output"></div>

<script>
// ===== CONFIG =====
const FLASH_UNIVERSE = ["SOLUSDT","APTUSDT","INJUSDT","PUMPUSDT","SOMIUSDT","VIRTUALUSDT","SUIUSDT","DUSKUSDT","CLOUSDT","JOJOUSDT","BROCCOLI714USDT","WIFUSDT","RENDERUSDT","XRPUSDT","PEPEUSDT","PIPPINUSDT","TTDUSDT","BULLAUSDT","EULUSDT","SPELLUSDT","BOMEUSDT","TURBOUSDT","MOGUSDT","MEMEUSDT","RAYUSDT","ORCAUSDT","MINAUSDT","QTUMUSDT","STXUSDT","PLUMEUSDT","IOTAUSDT","NEARUSDT","ARBUSDT","OPUSDT","FETUSDT","WLDUSDT","TAOUSDT"];
const MIN_VOLUME_USD = 5_000_000;
let CURRENT_MODE = "DIP";
const BTC_GATE = { maxDrop: -1.2, maxPump: 1.5, maxVol: 2.0 };
let btcGatePass = true;
const cache = new Map(); const CACHE_TTL = 5*60*1000;
let activeRequests = 0; const MAX_CONCURRENT = 6;

// ===== UTILITIES =====
function calculateEMA(prices, period){
  if(prices.length < period) return 0;
  const k = 2/(period+1);
  let ema = prices.slice(0,period).reduce((a,b)=>a+b,0)/period;
  for(let i=period;i<prices.length;i++) ema = prices[i]*k + ema*(1-k);
  return ema;
}
function getCacheKey(symbol){ return `${symbol}_klines`; }
function clearCache(){ cache.clear(); document.getElementById("scanStats").innerText="Cache cleared"; }

// ===== RATE-LIMIT FETCH =====
async function rateLimitedFetch(url,retries=3){
  for(let i=0;i<retries;i++){
    try{
      const controller = new AbortController();
      const timeoutId = setTimeout(()=>controller.abort(),10000);
      const res = await fetch(url,{signal:controller.signal});
      clearTimeout(timeoutId);
      if(res.status===429){ await new Promise(r=>setTimeout(r,(i+1)*1500)); continue; }
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    }catch(e){
      if(i===retries-1) throw e;
      await new Promise(r=>setTimeout(r,1000*(i+1)));
    }
  }
}

// ===== BTC GATE =====
async function fetchBTCGate(){
  try{
    const k = await rateLimitedFetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&limit=2`);
    const p = +k[0][4], c = +k[1][4];
    const ch = ((c-p)/p)*100;
    const vr = +k[1][7]/((+k[1][7])/24);
    btcGatePass = !(ch < BTC_GATE.maxDrop || ch > BTC_GATE.maxPump || vr > BTC_GATE.maxVol);
    document.getElementById("btcGateStatus").innerHTML = btcGatePass ? `<strong>‚úÖ BTC GATE PASS</strong> (${ch.toFixed(2)}%)` : `<strong>‚ùå BTC BLOCKED</strong> (${ch.toFixed(2)}%)`;
  }catch(e){ btcGatePass=true; document.getElementById("btcGateStatus").innerHTML="‚ö†Ô∏è BTC GATE UNAVAILABLE"; }
}

// ===== FETCH TICKER + EMA =====
async function fetchTickerWithEMA(symbol){
  const cacheKey=getCacheKey(symbol), now=Date.now();
  const cached=cache.get(cacheKey);
  if(cached&&(now-cached.timestamp)<CACHE_TTL) return cached.data;
  try{
    const [ticker,klines]=await Promise.all([
      rateLimitedFetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`),
      rateLimitedFetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=100`)
    ]);
    if(klines.length<99) return null;
    const closes=klines.map(k=>+k[4]);
    const data={
      price:+ticker.lastPrice,
      change:+ticker.priceChangePercent,
      vol:+ticker.quoteVolume,
      low:+ticker.lowPrice,
      high:+ticker.highPrice,
      ema7:calculateEMA(closes,7),
      ema25:calculateEMA(closes,25),
      ema99:calculateEMA(closes,99),
      fetchedAt:now
    };
    cache.set(cacheKey,{data,timestamp:now});
    return data;
  }catch(e){ console.error(symbol,e); return null; }
}

// ===== CONFIDENCE =====
function confidenceScore(d,mode){
  let score=0;
  if(mode==="MOMENTUM"){ if(!(d.change>=4 && d.change<=7)) return 0; score+=d.change>=6?45:35; }
  else { const dip=Math.abs(d.change); if(dip>=8&&dip<12)score+=30; else if(dip>=12&&dip<20)score+=40; else if(dip>=20)score+=45; else return 0; }
  if(d.vol>=60e6)score+=35; else if(d.vol>=40e6)score+=30; else if(d.vol>=20e6)score+=25; else if(d.vol>=MIN_VOLUME_USD)score+=20; else return 0;
  if(!(d.ema7>d.ema25*1.02 && d.ema25>d.ema99*1.01)) return 0;
  return Math.min(100,Math.round(score));
}

// ===== BUILD SIGNAL =====
function buildSignal(symbol,d){
  if(d.vol<MIN_VOLUME_USD) return null;
  let modeLabel,css,entry,hold;
  if(CURRENT_MODE==="DIP"){
    if(d.change>=-8) return null;
    modeLabel="DIP REVERSION";
    const dipPct=Math.abs(d.change);
    css=dipPct<12?"normal":dipPct<20?"flash":"chaos";
    entry=d.price*0.995;
    hold="12‚Äì36h";
  }else{
    if(!(d.change>=4&&d.change<=7)) return null;
    modeLabel="CONTINUATION";
    css="momentum";
    entry=d.price*0.997;
    hold="4‚Äì12h";
  }
  const conf=confidenceScore(d,CURRENT_MODE);
  if(conf<75) return null;

  let armPct=CURRENT_MODE==="DIP"?5:4;
  let trailPct=CURRENT_MODE==="DIP"?6:5;
  let noTrail=CURRENT_MODE==="DIP" && conf<82 && d.vol<MIN_VOLUME_USD*1.2;

  let trailHtml;
  if(noTrail){
    const dipPct=Math.abs(d.change);
    const tpPct=dipPct<12?0.10:0.12;
    const tpPrice=entry*(1+tpPct);
    trailHtml=`‚ùå NO-TRAIL ‚Üí Fixed TP ${tpPct*100}% ‚Üí $${tpPrice.toFixed(8)}`;
  }else{
    const armPrice=entry*(1+armPct/100);
    const lockMin=entry*(1+2/100);
    const lockMax=entry*(1+4/100);
    trailHtml=`ü™Ç AUTO-TRAIL:
‚Ä¢ Arm +${armPct}% ‚Üí $${armPrice.toFixed(8)}
‚Ä¢ Trail ${trailPct}%
‚Ä¢ Lock +2‚Äì4% ‚Üí $${lockMin.toFixed(8)}‚Äì$${lockMax.toFixed(8)}`;
  }

  const decimals=d.price<0.1?8:d.price<1?6:4;
  return {
    conf,
    html:`<div class="signal ${css}">
<span class="rank">‚≠ê ${conf}/100</span> | ${symbol.replace("USDT","")} ‚Äî ${modeLabel}
<br><strong>LIVE:</strong> $${d.price.toFixed(decimals)}
<br><strong>ENTRY:</strong> $${entry.toFixed(decimals)}
<br><strong>HOLD:</strong> ${hold}
<br>${trailHtml}
</div>`
  };
}

// ===== PARALLEL SCAN =====
async function runScan(){
  const startTime=performance.now();
  const outputEl=document.getElementById("output");
  outputEl.innerHTML="‚è≥ BTC Gate...";
  await fetchBTCGate();
  if(!btcGatePass){ outputEl.innerHTML="<div class='stats'>‚ùå BTC Gate failed</div>"; return; }
  outputEl.innerHTML="‚è≥ Parallel scan...";
  const signals=[];
  for(let i=0;i<FLASH_UNIVERSE.length;i+=MAX_CONCURRENT){
    const batch=FLASH_UNIVERSE.slice(i,i+MAX_CONCURRENT);
    const batchPromises=batch.map(async symbol=>{
      const data=await fetchTickerWithEMA(symbol);
      if(data){
        const signal=buildSignal(symbol,data);
        if(signal) signals.push(signal);
      }
    });
    await Promise.allSettled(batchPromises);
    await new Promise(r=>setTimeout(r,200));
  }
  signals.sort((a,b)=>b.conf-a.conf);
  outputEl.innerHTML=signals.length===0? "<div class='stats'>‚úÖ No signals (‚â•75 conf). Market clean.</div>" : signals.map(s=>s.html).join("");
  document.getElementById("scanStats").innerText=`‚úÖ ${signals.length} signals | ${((performance.now()-startTime)/1000).toFixed(1)}s | Cache: ${cache.size}/${FLASH_UNIVERSE.length}`;
}

// ===== MODE TOGGLE =====
function toggleMode(){
  CURRENT_MODE=CURRENT_MODE==="DIP"?"MOMENTUM":"DIP";
  document.getElementById("modeBtn").innerText=CURRENT_MODE==="DIP"?"üìâ Mode: DIP":"‚ö° Mode: MOMENTUM";
}
</script>
</body>
</html>
