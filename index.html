<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>üöÄ FLASH SCANNER v10.0 ‚Äî Screenshot + Velocity Only</title>
<style>
body { font-family: monospace; background:#0f0f15; color:#eee; padding:20px; }
.signal { margin:12px 0; padding:10px; border-radius:6px; }
.flash { background:#2a1a3a; border-left:4px solid #ff6b6b; }
.normal { background:#1a2a2a; border-left:4px solid #4ecdc4; }
.momentum { background:#3a1a5a; border-left:4px solid #a678ff; }
.chaos { background:#1a0f1a; border-left:4px solid #ffcc00; }
.rank { color:#ffcc00; font-weight:bold; }
button { background:#222; color:#ffcc00; border:1px solid #444; padding:6px 10px; margin-right:6px; cursor:pointer; }
</style>
</head>
<body>
<h2>üöÄ FLASH SCANNER v10.0 ‚Äî Screenshot + Velocity Only</h2>
<p>Confidence ‚â•75 | BTC 1h Gate | Vol ‚â•$5M | EMA7 > EMA25√ó1.02</p>

<button onclick="runScan()">‚ñ∂ Run Scan</button>
<button onclick="toggleMode()" id="modeBtn">üìâ Mode: DIP</button>

<div id="btcGateStatus" style="margin-top:10px;"></div>
<div id="output" style="margin-top:20px;"></div>

<script>
// ========= 35-COIN FLASH UNIVERSE (Screenshot-Validated Only) =========
const FLASH_UNIVERSE = [
  // ALPHA WINNERS (from your screenshots)
  "CLOUSDT","JOJOUSDT","LYNUSDT","DOYRUSDT","AITECHUSDT","YALAUSDT","GAIXUSDT",
  // MEME ROCKETS
  "BROCCOLI714USDT","WIFUSDT","PNUTUSDT","BOMEUSDT","TUTUSDT","TSTUSDT",
  // SOLANA SPEED
  "RENDERUSDT","ORCAUSDT","RAYUSDT","ACTUSDT",
  // CORE MEMES
  "GOATUSDT","PEPEUSDT","POPCATUSDT","MOGUSDT","TURBOUSDT","MEMEUSDT",
  // DIP MONSTERS
  "PIPPINUSDT","BULLAUSDT","TTDUSDT","FSTUSDT","ICNTUSDT"
];

const ALL_COINS = FLASH_UNIVERSE;
const MIN_VOLUME_USD = 5_000_000; // Your proven floor
let CURRENT_MODE = "DIP";

/* ========= BTC 1h GATE ========= */
const BTC_GATE = { maxDrop: -1.2, maxPump: 1.5, maxVol: 2.0 };
let btcGatePass = true;

async function fetchBTCGate() {
  try {
    const k = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&limit=2`).then(r => r.json());
    const p = +k[0][4], c = +k[1][4];
    const ch = ((c - p) / p) * 100;
    const v1h = +k[1][7];
    const t = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT`).then(r => r.json());
    const avg = (+t.quoteVolume) / 24;
    const vr = v1h / avg;
    btcGatePass = !(ch < BTC_GATE.maxDrop || ch > BTC_GATE.maxPump || vr > BTC_GATE.maxVol);
    document.getElementById("btcGateStatus").innerHTML = btcGatePass ?
      `‚úÖ BTC PASS (${ch.toFixed(2)}%, Vol ${vr.toFixed(2)}x)` :
      `‚ùå BTC BLOCK (${ch.toFixed(2)}%, Vol ${vr.toFixed(2)}x)`;
  } catch {
    btcGatePass = true;
  }
}

/* ========= FETCH TICKER + EMA (1h) ========= */
async function fetchTickerWithEMA(symbol) {
  try {
    const tickerRes = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`);
    const ticker = await tickerRes.json();
    
    const klinesRes = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=100`);
    const klines = await klinesRes.json();
    
    if (klines.length < 99) return null;
    
    const closes = klines.map(k => parseFloat(k[4]));
    const ema7 = calculateEMA(closes, 7);
    const ema25 = calculateEMA(closes, 25);
    const ema99 = calculateEMA(closes, 99);
    
    return {
      price: parseFloat(ticker.lastPrice),
      change: parseFloat(ticker.priceChangePercent),
      vol: parseFloat(ticker.quoteVolume),
      low: parseFloat(ticker.lowPrice),
      high: parseFloat(ticker.highPrice),
      ema7: ema7,
      ema25: ema25,
      ema99: ema99
    };
  } catch (e) {
    return null;
  }
}

function calculateEMA(prices, period) {
  const k = 2 / (period + 1);
  let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
  for (let i = period; i < prices.length; i++) {
    ema = prices[i] * k + ema * (1 - k);
  }
  return ema;
}

/* ========= TOGGLE MODE ========= */
function toggleMode() {
  CURRENT_MODE = CURRENT_MODE === "DIP" ? "MOMENTUM" : "DIP";
  document.getElementById("modeBtn").innerText =
    CURRENT_MODE === "DIP" ? "üìâ Mode: DIP" : "‚ö° Mode: MOMENTUM";
}

/* ========= CONFIDENCE SCORE ========= */
function confidenceScore(d, mode) {
  let score = 0;

  if (mode === "MOMENTUM") {
    if (d.change >= 4 && d.change <= 7) {
      score += d.change >= 6 ? 45 : 35;
    } else {
      return 0;
    }
  } else {
    const dip = Math.abs(d.change);
    if (dip >= 8 && dip < 12) score += 30;
    else if (dip >= 12 && dip < 20) score += 40;
    else if (dip >= 20) score += 45;
    else return 0;
  }

  if (d.vol >= 60e6) score += 35;
  else if (d.vol >= 40e6) score += 30;
  else if (d.vol >= 20e6) score += 25;
  else if (d.vol >= MIN_VOLUME_USD) score += 20;
  else return 0;

  if (!(d.ema7 > d.ema25 * 1.02 && d.ema25 > d.ema99 * 1.01)) return 0;

  if (mode === "MOMENTUM") {
    const pullback = ((d.high - d.price) / d.high) * 100;
    if (pullback >= 0.8 && pullback <= 1.5) score += 15;
    else return 0;
    if (d.price < d.ema25) return 0;
  }

  return Math.min(100, Math.round(score));
}

/* ========= SIGNAL ENGINE ========= */
function buildSignal(symbol, d) {
  if (d.vol < MIN_VOLUME_USD) return null;

  let mode, css, entry, hold;

  if (CURRENT_MODE === "DIP") {
    if (d.change >= -8) return null;
    const dip = Math.abs(d.change);
    if (dip < 12) { mode = "NORMAL"; css = "normal"; }
    else if (dip < 20) { mode = "FLASH"; css = "flash"; }
    else { mode = "CHAOS"; css = "chaos"; }
    entry = d.price * (1 - 0.005);
    hold = "12‚Äì36h";
  }

  if (CURRENT_MODE === "MOMENTUM") {
    if (d.change < 4 || d.change > 7) return null;
    const pullback = ((d.high - d.price) / d.high) * 100;
    if (pullback < 0.8 || pullback > 1.5) return null;
    if (!(d.ema7 > d.ema25 * 1.02 && d.ema25 > d.ema99 * 1.01)) return null;
    if (d.price < d.ema25) return null;
    entry = d.price * (1 - pullback / 100 * 0.5);
    mode = "MOMO-PULLBACK";
    css = "momentum";
    hold = "4‚Äì12h";
  }

  const conf = confidenceScore(d, CURRENT_MODE);
  if (conf < 75) return null;

  let tp = conf > 85 && d.vol >= 40e6 ? "12%" : "10%";

  const priceDecimals = d.price < 0.1 ? 8 : d.price < 1 ? 6 : d.price < 10 ? 4 : 2;
  const entryDecimals = entry < 0.1 ? 8 : entry < 1 ? 6 : entry < 10 ? 4 : 2;

  return {
    conf,
    html: `
<div class="signal ${css}">
<span class="rank">‚≠ê ${conf}/100</span> | ${symbol.replace("USDT", "")} ‚Äî ${mode}
<br>Price $${d.price.toFixed(priceDecimals)} | 24h ${d.change.toFixed(2)}%
<br>Entry $${entry.toFixed(entryDecimals)} ‚Üí TP ${tp} | ${hold}
</div>`
  };
}

/* ========= RUN SCAN ========= */
async function runScan() {
  const out = document.getElementById("output");
  out.innerHTML = "‚è≥ BTC Gate...";
  await fetchBTCGate();
  if (!btcGatePass) {
    out.innerHTML += "<br>Scan blocked by BTC Gate";
    return;
  }

  let signals = [];
  for (const s of ALL_COINS) {
    const d = await fetchTickerWithEMA(s);
    if (d) {
      const sig = buildSignal(s, d);
      if (sig) signals.push(sig);
    }
  }

  signals = signals.filter(sig => sig.conf >= 75).sort((a, b) => b.conf - a.conf);
  if (signals.length === 0) {
    out.innerHTML = "<div>No high-confidence (‚â•75) signals found.</div>";
    return;
  }

  out.innerHTML = signals.map(s => s.html).join("");
}
</script>
</body>
</html>
