<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Grid Scanner</title>
  <style>
    body { background: #000; color: #0f0; font-family: monospace; padding: 10px; margin: 0; }
    .header { color: #0ff; font-size: 1.4em; margin: 10px 0; }
    .signal { margin: 8px 0; padding: 8px; border: 1px solid #0a0; background: #001500; }
    .coin { font-weight: bold; color: #ff0; }
    .status { color: #0f0; }
    .reason { font-size: 0.85em; opacity: 0.8; margin-top: 4px; }
    .progress { color: #888; margin: 10px 0; }
    .error { color: #f44; }
    .footer { color: #666; font-size: 0.8em; margin-top: 15px; }
  </style>
</head>
<body>
  <div class="header">üîç Grid Scanner</div>
  <div id="progress" class="progress">Checking BTC status...</div>
  <div id="output"></div>
  <div class="footer">‚úÖ Rules: Vol‚â•$8M ‚Ä¢ EMA flat ‚Ä¢ Higher low ‚Ä¢ Dip‚â•15% ‚Ä¢ RSI6‚â§30</div>

  <script>
    // === YOUR 5 HARD RULES ===
    const MIN_VOLUME = 8_000_000;
    const BATCH_SIZE = 50;

    const sleep = ms => new Promise(r => setTimeout(r, ms));

    // === HELPER: Calculate EMA (candles[0] = newest) ===
    function calculateEMA(candles, period) {
      const k = 2 / (period + 1);
      let ema = candles[0].c;
      const emas = [ema];
      for (let i = 1; i < candles.length; i++) {
        ema = (candles[i].c * k) + (ema * (1 - k));
        emas.push(ema);
      }
      return emas;
    }

    // === HELPER: Calculate RSI (candles[0] = newest) ===
    function calculateRSI(candles, period) {
      if (candles.length < period + 1) return 100;
      let gains = 0, losses = 0;
      for (let i = 0; i < period; i++) {
        const change = candles[i].c - candles[i + 1].c;
        if (change > 0) gains += change;
        else losses += Math.abs(change);
      }
      const rs = gains / (losses || 1);
      return 100 - (100 / (1 + rs));
    }

    // === RULE 1: BTC STABLE (Price > EMA20 on 1h) ===
    async function isBtcStable() {
      try {
        const res = await fetch('https://api.bybit.com/v5/market/kline?category=linear&symbol=BTCUSDT&interval=60&limit=50');
        const data = await res.json();
        if (!data.result?.list || data.result.list.length < 21) return false;

        const closes = data.result.list.map(c => parseFloat(c[4]));
        let ema = closes[0];
        const k = 2 / 21;
        for (let i = 1; i < 21; i++) {
          ema = (closes[i] * k) + (ema * (1 - k));
        }
        return closes[0] > ema;
      } catch (e) {
        return false;
      }
    }

    // === RULE 3: EMA FLAT + COMPRESSION ===
    function checkEMAFlat(candles) {
      const ema7 = calculateEMA(candles, 7);
      const ema25 = calculateEMA(candles, 25);

      const slope7 = Math.abs((ema7[0] - ema7[2]) / ema7[2]);
      const slope25 = Math.abs((ema25[0] - ema25[2]) / ema25[2]);
      const diffPct = Math.abs(ema7[0] - ema25[0]) / ema25[0];

      return slope7 < 0.001 && slope25 < 0.001 && diffPct <= 0.025;
    }

    // === RULE 4: HIGHER LOW CONFIRMED ===
    function checkHigherLow(candles) {
      if (candles.length < 48) return false;
      const recentLow = Math.min(...candles.slice(0, 24).map(c => c.l));
      const priorLow = Math.min(...candles.slice(24, 48).map(c => c.l));
      return recentLow > priorLow;
    }

    // === RULE 5: CLEAN DIP ===
    function checkCleanDip(candles) {
      if (candles.length < 24) return false;
      const high24 = Math.max(...candles.slice(0, 24).map(c => c.h));
      const dipPct = (high24 - candles[0].c) / high24;
      if (dipPct < 0.15) return false;

      const rsi6 = calculateRSI(candles, 6);
      if (rsi6 > 30) return false;

      const dipVol = candles.slice(0, 6).reduce((s, c) => s + c.v, 0);
      const avgVol = candles.slice(0, 24).reduce((s, c) => s + c.v, 0) / 24;
      if (dipVol >= avgVol * 0.8) return false;

      return true;
    }

    // === RULE 2: VOLUME ‚â• $8M ===
    async function fetchAllSymbols() {
      const res = await fetch('https://api.bybit.com/v5/market/tickers?category=linear');
      const data = await res.json();
      return data.result.list
        .filter(t => 
          t.symbol.endsWith('USDT') && 
          parseFloat(t.volume24h) >= MIN_VOLUME &&
          parseFloat(t.lastPrice) > 0.0001
        )
        .map(t => t.symbol);
    }

    // === ANALYZE ONE COIN ===
    async function analyzeCoin(symbol) {
      try {
        const res = await fetch(`https://api.bybit.com/v5/market/kline?category=linear&symbol=${symbol}&interval=60&limit=50`);
        const data = await res.json();
        if (!data.result?.list || data.result.list.length < 50) return null;

        const candles = data.result.list.map(c => ({
          h: parseFloat(c[2]),
          l: parseFloat(c[3]),
          c: parseFloat(c[4]),
          v: parseFloat(c[5])
        }));

        if (candles[0].c < 0.001) return null;
        if (!checkEMAFlat(candles)) return null;
        if (!checkHigherLow(candles)) return null;
        if (!checkCleanDip(candles)) return null;

        const high24 = Math.max(...candles.slice(0, 24).map(c => c.h));
        const dipPct = ((high24 - candles[0].c) / high24) * 100;
        const rsi6 = calculateRSI(candles, 6).toFixed(0);

        return { symbol, leverage: "x5", dipPct: dipPct.toFixed(1), rsi6 };
      } catch (e) {
        return null;
      }
    }

    // === BATCH PROCESSOR ===
    async function processBatch(symbols, start, total, updateProgress) {
      const end = Math.min(start + BATCH_SIZE, symbols.length);
      updateProgress(`Scanning ${start+1}-${end} of ${total}...`);

      const promises = symbols.slice(start, end).map(sym => analyzeCoin(sym));
      const results = (await Promise.all(promises)).filter(r => r);

      await sleep(600);
      return results;
    }

    // === MAIN SCAN ===
    async function runScan() {
      document.getElementById("progress").textContent = "Checking BTC stability...";
      
      if (!(await isBtcStable())) {
        document.getElementById("output").innerHTML = '<div class="error">üõë BTC unstable ‚Äî no grids allowed</div>';
        return;
      }

      document.getElementById("progress").textContent = "Fetching all coins...";
      const symbols = await fetchAllSymbols();
      
      if (symbols.length === 0) {
        document.getElementById("output").innerHTML = '<div class="error">‚ùå No coins meet volume threshold</div>';
        return;
      }

      let allResults = [];
      const total = symbols.length;
      const updateProgress = msg => {
        document.getElementById("progress").textContent = msg;
      };

      for (let i = 0; i < total; i += BATCH_SIZE) {
        const batchResults = await processBatch(symbols, i, total, updateProgress);
        allResults = allResults.concat(batchResults);
      }

      if (allResults.length === 0) {
        document.getElementById("output").innerHTML = '<div class="progress">üü¢ No clean grid signals found</div>';
        document.getElementById("progress").textContent = "Scan complete.";
      } else {
        let html = "";
        allResults.forEach(r => {
          html += `
            <div class="signal">
              <span class="coin">${r.symbol}</span>
              <span class="status">[${r.leverage} GRID] ‚úÖ APPROVED</span>
              <div class="reason">Dip: ${r.dipPct}% | RSI6: ${r.rsi6}</div>
            </div>
          `;
        });
        document.getElementById("output").innerHTML = html;
        document.getElementById("progress").textContent = `‚úÖ Found ${allResults.length} clean signal(s)`;
      }
    }

    runScan();
  </script>
</body>
</html>
