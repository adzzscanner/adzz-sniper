<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>Adzz Sniper â€” FINAL v7.2</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { 
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', monospace; 
  background: #0b0b16; 
  color: #0af; 
  padding: 8px; 
  line-height: 1.4; 
  overflow-x: hidden;
}
h1 { 
  color: #0f0; 
  text-align: center; 
  font-size: 1.25em; 
  margin: 6px 0;
}
.container { max-width: 100%; margin: 0 auto; padding: 0 4px; }
.status { 
  background: #1a1a2e; 
  padding: 8px; 
  border-radius: 6px; 
  text-align: center; 
  margin: 10px 0; 
  font-size: 0.95em;
  color: #ffaa00;
}
.section { 
  background: #16213e; 
  padding: 10px; 
  margin: 10px 0; 
  border-radius: 6px; 
  font-size: 0.95em;
}
.flash { border-left: 4px solid #4488ff; }
.normal { border-left: 4px solid #0f0; }
.coin-row { 
  padding: 10px; 
  margin: 6px 0; 
  background: #0d0d1a; 
  border-radius: 6px; 
  font-size: 1.15em; 
  word-break: break-all;
}
.tp-levels { font-size: 1.05em; color: #88f; margin-top: 4px; }
.tp-main { color: #0f0; font-weight: bold; }
.high-conviction { color: #ffff00; font-weight: bold; }
.volatility-score { font-size: 0.85em; color: #aaa; margin-top: 4px; }
.button-container { text-align: center; margin: 15px 0; }
button { 
  padding: 12px 24px; 
  background: #0f0; 
  color: #000; 
  border: none; 
  font-weight: bold; 
  border-radius: 6px; 
  font-size: 1.1em; 
  cursor: pointer; 
  width: 100%;
  max-width: 300px;
  margin: 0 auto;
}
.manual-note { 
  background: #2a0a3a; 
  padding: 10px; 
  border-left: 4px solid #ff55ff; 
  margin: 15px 0; 
  font-size: 0.95em; 
  text-align: center;
  border-radius: 6px;
}
</style>
</head>
<body>
<div class="container">
  <h1>Adzz Sniper â€” FINAL v7.2</h1>
  <div class="status" id="status">Tap "SCAN" â€” MAX 15% TP, MIN 10%</div>

  <div class="manual-note">
    ðŸŸ¢ 8â€“12% dip â†’ 10% TP â€¢ ðŸŸ¦ 12â€“20%+ dip â†’ 15% (strong) / 10% (weak)<br>
    âœ… BTC 2â€“6% â†’ Flash UNLOCKED â€¢ DOM = INSTANT PASS/REJECT
  </div>

  <div class="section normal">
    <h3>ðŸŸ¢ NORMAL: 8â€“12% dips â†’ 10% TP (BTC &lt;8%)</h3>
    <div id="normalOutput">No setups</div>
  </div>

  <div class="section flash">
    <h3>ðŸŸ¦ FLASH: 12â€“20%+ dips â†’ 15%/10% (BTC 2â€“6% ONLY)</h3>
    <div id="flashOutput">No setups</div>
  </div>

  <div class="button-container">
    <button onclick="startScan()">SCAN</button>
  </div>
</div>

<script>
// âœ… 47-COIN UNIVERSE â€” FINAL v7.2
// ðŸ”¹ Flash ONLY when BTC = 2â€“6%
// ðŸ”¹ Normal = BTC <8%
// ðŸ”¹ MAX TP = 15% | MIN = 10%

const NORMAL_COINS = [
  "JUP","PYTH","PIXEL","TNSR","STG","HOOK","MAGIC","ZRO",
  "PORTAL","NIL","ONDO","W","INJ","TAO","FET","RENDER","SEI","SUI"
];

const FLASH_COINS = [
  "APT","ARB","OP","IMX","NEAR","MATIC","LINK","RNDR",
  "XPL","POWER","STORJ","SQD","WLD","COAI","DOT","ONT","ZETA"
];

const CHAOS_COINS = [
  "BEAT","TRU","KAITO","TRADOOR","ARTX","AVNT","CYBER","ALT",
  "TIA","SKY","FLOW","STABLE"
];

const ALL_COINS = [...NORMAL_COINS, ...FLASH_COINS, ...CHAOS_COINS];

const BASE_URL = "https://api.binance.com/api/v3";

async function fetchWithRetry(url, retries = 2, timeoutMs = 8000) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch(url, { signal: controller.signal });
    clearTimeout(timeout);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  } catch (e) {
    clearTimeout(timeout);
    if (retries > 0) {
      await new Promise(r => setTimeout(r, 500));
      return fetchWithRetry(url, retries - 1, timeoutMs);
    }
    return null;
  }
}

async function fetchKlines(symbol, interval, limit) {
  return await fetchWithRetry(`${BASE_URL}/klines?symbol=${symbol}USDT&interval=${interval}&limit=${limit}`);
}

async function getBTCRange(interval, limit) {
  const klines = await fetchKlines("BTC", interval, limit);
  if (!klines || klines.length === 0) return 0;
  const highs = klines.map(k => parseFloat(k[2]));
  const lows = klines.map(k => parseFloat(k[3]));
  const high = Math.max(...highs);
  const low = Math.min(...lows);
  return ((high - low) / low) * 100;
}

function calculateRSI(prices, period = 6) {
  if (prices.length < period + 1) return 50;
  let gains = 0, losses = 0;
  for (let i = prices.length - period; i < prices.length; i++) {
    const diff = prices[i] - prices[i - 1];
    if (diff > 0) gains += diff;
    else losses -= diff;
  }
  if (losses === 0) return 100;
  if (gains === 0) return 0;
  const rs = gains / losses;
  return 100 - (100 / (1 + rs));
}

function calculateVolatilityScore(drop, volSpike, price) {
  let priceMultiplier = 1.0;
  if (price < 0.5) priceMultiplier = 1.8;
  else if (price < 1.0) priceMultiplier = 1.5;
  else if (price < 2.0) priceMultiplier = 1.2;
  else if (price > 5.0) priceMultiplier = 0.7;
  return drop * Math.min(volSpike, 3.0) * priceMultiplier;
}

function calculateEMA(prices, period) {
  const k = 2 / (period + 1);
  let ema = prices[0];
  for (let i = 1; i < prices.length; i++) {
    ema = prices[i]*k + ema*(1-k);
  }
  return ema;
}

function isNearLow(lows, price, pct=2) {
  const minLow = Math.min(...lows);
  return price <= minLow*(1 + pct/100);
}

function calculateDrop(highs, currentPrice) {
  const recentHigh = Math.max(...highs);
  return recentHigh>0 ? ((recentHigh-currentPrice)/recentHigh)*100 : 0;
}

function isFakeVolume(high, low, close, volume) {
  const priceRangePct = ((high - low) / close) * 100;
  const minRange = (close < 1) ? 1.5 : 1.0;
  return volume > 100_000 && priceRangePct < minRange;
}

async function autoCheckDOM(coin, mode) {
  try {
    const res = await fetch(`https://api.binance.com/api/v3/depth?symbol=${coin}USDT&limit=20`);
    if (!res.ok) return false;
    const data = await res.json();
    
    const bids = data.bids.slice(0,5).map(b => [parseFloat(b[0]), parseFloat(b[1])]);
    const asks = data.asks.slice(0,5).map(a => [parseFloat(a[0]), parseFloat(a[1])]);
    
    const bidUSDT = bids.reduce((sum, b) => sum + b[0]*b[1], 0);
    const askUSDT = asks.reduce((sum, a) => sum + a[0]*a[1], 0);
    const ratio = bidUSDT / askUSDT;
    
    if (ratio < 1.0) return false;
    if ((mode === 'Chaos' || mode === 'Flash') && ratio < 1.1) return false;
    return true;
  } catch (e) {
    return false;
  }
}

function renderCoinRow(data) {
  const { coin, zone, price, tp, highConv, volatilityScore } = data;

  let entryLow = price * 0.99;
  let entryHigh = price * 1.01;
  if (zone === 'Flash') {
    entryLow = price * 0.97;
    entryHigh = price * 1.02;
  }
  entryLow = entryLow.toFixed(4);
  entryHigh = entryHigh.toFixed(4);

  const icons = { Normal: 'ðŸŸ¢', Flash: 'ðŸŸ¦' };
  const badge = highConv ? ' <span class="high-conviction">ðŸ”¥</span>' : '';
  const speedBadge = volatilityScore >= 50 ? ' âš¡' : '';

  const tpPct = ((tp / price) - 1) * 100;
  let tpLabel = zone === 'Normal' ? '10%' : (tpPct >= 14.5 ? '15%' : '10%');

  return `
    <div class="coin-row">
      ${icons[zone]} ${coin}${badge}${speedBadge} â€” $${price.toFixed(4)}<br>
      <span class="tp-levels">Entry: $${entryLow} â€“ $${entryHigh} | TP <span class="tp-main">$${tp.toFixed(4)}</span> (${tpLabel})</span>
      <div class="volatility-score">Volatility: ${volatilityScore.toFixed(1)}</div>
    </div>
  `;
}

async function detectZone(coin, btc24hRange, btcStable) {
  if (!btcStable) return null;

  const isNormal = NORMAL_COINS.includes(coin);
  const isFlashEligible = FLASH_COINS.includes(coin) || CHAOS_COINS.includes(coin);
  
  const interval = '1h';
  const limit = 25;
  const klines = await fetchKlines(coin, interval, limit);
  if (!klines || klines.length < limit) return null;

  const highs = klines.map(k=>parseFloat(k[2]));
  const lows = klines.map(k=>parseFloat(k[3]));
  const closes = klines.map(k=>parseFloat(k[4]));
  const vols = klines.map(k=>parseFloat(k[5]));
  const price = closes[closes.length-1];
  const drop = calculateDrop(highs, price);

  const lastCandle = klines[klines.length - 1];
  const high = parseFloat(lastCandle[2]);
  const low = parseFloat(lastCandle[3]);
  const close = parseFloat(lastCandle[4]);
  const volume = parseFloat(lastCandle[5]);

  if (isFakeVolume(high, low, close, volume)) return null;
  if ((high - low) / price < 0.015) return null;

  const vol24 = vols.slice(-24).reduce((a,b)=>a+b,0);
  if (vol24 < 2_000_000) return null;

  const ema7 = calculateEMA(closes.slice(-7), 7);
  const ema25 = calculateEMA(closes.slice(-25), 25);
  const nearLow = isNearLow(lows.slice(-6), price, 4);

  if (!nearLow || !(ema7 < ema25 * 1.01)) return null;

  const volAvg24 = vols.slice(-25,-1).reduce((a,b)=>a+b,0)/24;
  const volSpike = volAvg24 > 0 ? vols[vols.length-1] / volAvg24 : 1.0;
  if (volSpike < 1.5) return null;

  // ðŸ”¥ Normal: allowed if BTC <8%
  if (isNormal && drop >= 8 && drop <= 12) {
    const volatilityScore = calculateVolatilityScore(drop, volSpike, price);
    return { zone: 'Normal', coin, price, tp: price * 1.10, highConv: true, volatilityScore };
  }

  // ðŸ”¥ Flash: ONLY if BTC 2â€“6%
  if (isFlashEligible && btc24hRange >= 2 && btc24hRange <= 6 && drop > 12 && drop <= 70) {
    const volatilityScore = calculateVolatilityScore(drop, volSpike, price);
    const tp = volatilityScore >= 50 ? price * 1.15 : price * 1.10;
    return { zone: 'Flash', coin, price, tp, highConv: volatilityScore >= 50, volatilityScore };
  }

  return null;
}

function renderZoneSection(zoneId, results) {
  const outputEl = document.getElementById(`${zoneId}Output`);
  if (results.length > 0) {
    results.sort((a,b) => b.volatilityScore - a.volatilityScore);
    const maxShow = zoneId === 'flash' ? 2 : 5;
    outputEl.innerHTML = results.slice(0, maxShow).map(renderCoinRow).join('');
  } else {
    outputEl.innerHTML = `<div class="status">No setups</div>`;
  }
}

async function startScan() {
  const status = document.getElementById('status');
  status.innerHTML = "ðŸ”„ Checking BTC regime...";

  const [btc48h, btc24h] = await Promise.all([
    getBTCRange('4h', 25),
    getBTCRange('1h', 25)
  ]);

  const btcStable = btc48h < 8;
  const flashSafe = btcStable && btc24h >= 2 && btc24h <= 6;
  const flashText = flashSafe ? 'ðŸŸ¢ Flash-UNLOCKED' : 'âšª Flash-Locked';

  if (!btcStable) {
    status.innerHTML = `<span style="color:#ff5555;font-weight:bold;">ðŸ”´ BTC volatile â€” NO TRADE</span>`;
    ['normal','flash'].forEach(id => {
      document.getElementById(`${id}Output`).innerHTML = '<div class="status">Market not tradeable</div>';
    });
    return;
  }

  status.innerHTML = `ðŸŸ¢ BTC: ${btc48h.toFixed(1)}% â€¢ ${flashText}<br>Scanning ${ALL_COINS.length} coins...`;

  const normalResults = [];
  const flashResults = [];

  for (let i = 0; i < ALL_COINS.length; i++) {
    const coin = ALL_COINS[i];
    const signal = await detectZone(coin, btc24h, btcStable);
    if (signal) {
      const mode = CHAOS_COINS.includes(coin) ? 'Chaos' : (FLASH_COINS.includes(coin) ? 'Flash' : 'Normal');
      const domOK = await autoCheckDOM(coin, mode);
      if (domOK) {
        if (signal.zone === 'Normal') normalResults.push(signal);
        else if (signal.zone === 'Flash') flashResults.push(signal);
      }
    }
    if (i % 5 === 0) await new Promise(r => setTimeout(r, 100));
  }

  renderZoneSection('normal', normalResults);
  renderZoneSection('flash', flashResults);

  const totalValid = normalResults.length + flashResults.length;
  status.innerHTML = `ðŸŸ¢ BTC: ${btc48h.toFixed(1)}% â€¢ ${flashText}<br><strong>${totalValid} clean setups</strong>`;
}
</script>
</body>
</html>
