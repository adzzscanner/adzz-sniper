<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name=" viewport" content="width=device-width, initial-scale=1.0"/>
<title>üöÄ FLASH SCANNER v11.12 ‚Äî TRUSTED SIGNALS</title>
<style>
body { font-family: monospace; background:#0f0f15; color:#eee; padding:20px; }
.signal { margin:12px 0; padding:12px; border-radius:6px; }
.flash { background:#2a1a3a; border-left:4px solid #ff6b6b; }
.normal { background:#1a2a2a; border-left:4px solid #4ecdc4; }
.momentum { background:#3a1a5a; border-left:4px solid #a678ff; }
.chaos { background:#1a0f1a; border-left:4px solid #ffcc00; }
.rank { color:#ffcc00; font-weight:bold; }
button { background:#222; color:#ffcc00; border:1px solid #444; padding:10px 16px; margin-right:6px; cursor:pointer; font-weight:bold; }
.stats { background:#1a2a2a; padding:15px; border-radius:8px; margin:10px 0; }
</style>
</head>
<body>

<h2>üöÄ FLASH SCANNER v11.12 ‚Äî TRUSTED SIGNALS</h2>

<button onclick="runScan()">üîç RUN SCAN</button>
<button onclick="toggleMode()" id="modeBtn">üìâ Mode: DIP</button>
<button onclick="clearCache()">üßπ CLEAR CACHE</button>
<button onclick="toggleDebug()" id="debugBtn">üêõ Debug: OFF</button>

<div id="btcGateStatus" class="stats"></div>
<div id="scanStats" class="stats"></div>
<div id="debugLog" class="stats" style="display:none; background:#2a1a2a; font-size:0.8em;"></div>
<div id="output"></div>

<script>
// ===== DEDUPLICATED COIN LIST =====
const FLASH_UNIVERSE = [...new Set([
"APTUSDT","INJUSDT","PUMPUSDT","SOMIUSDT","SUIUSDT","DUSKUSDT","CLOUSDT","JOJOUSDT",
"BROCCOLI714USDT","WIFUSDT","RENDERUSDT","XRPUSDT","PEPEUSDT","PIPPINUSDT","TTDUSDT",
"BULLAUSDT","EULUSDT","SPELLUSDT","BOMEUSDT","TURBOUSDT","MOGUSDT","MEMEUSDT","RAYUSDT",
"ORCAUSDT","MINAUSDT","QTUMUSDT","STXUSDT","PLUMEUSDT","IOTAUSDT","NEARUSDT","ARBUSDT",
"OPUSDT","FETUSDT","WLDUSDT","TAOUSDT","XPLUSDT","STGUSDT","PIXELUSDT","MAGICUSDT",
"1000SATSUSDT","BONKUSDT","LUNAUSDT","NILUSDT","TNSRUSDT","BATUSDT","HOOKUSDT","FLOKIUSDT",
"XAIUSDT","ZROUSDT","MTLUSDT","PYTHUSDT","JUPUSDT","GALAUSDT","SKLUSDT","WUSDT","PORTALUSDT",
"LUNCUSDT","AIOTUSDT","HYPERUSDT","GUSDT","TIAUSDT","TRBUSDT","ZILUSDT","PENGUUSDT","SEIUSDT",
"GUNUSDT","ZKUSDT","JASMYUSDT","VIRTUALUSDT"
])];

const MIN_VOLUME_DIP = 4_000_000;
const MIN_VOLUME_MOM = 1_000_000;
let CURRENT_MODE = "DIP";
const BTC_GATE = { maxDrop: -1.5, maxPump: 2.0, maxVol: 3.0 };
let btcGatePass = true;
const cache = new Map();
const CACHE_TTL = 5 * 60 * 1000;
const MAX_CONCURRENT = 4;
let DEBUG_MODE = false;
const FETCH_ERROR_LOG = new Set();

// ===== UTILITIES =====
function calculateEMA(prices, period) {
    if (prices.length < period) return NaN;
    const k = 2 / (period + 1);
    let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
    for (let i = period; i < prices.length; i++) {
        ema = prices[i] * k + ema * (1 - k);
    }
    return ema;
}

function isFakeResponse(text) {
    return (
        text.includes("<!DOCTYPE") ||
        text.includes("<html") ||
        text.includes("Warga Jakarta") ||
        text.includes("HP Android") ||
        text.includes("Suzuki Jimny") ||
        text.includes("Satelit Merah Putih") ||
        text.trim().length === 0
    );
}

function getCacheKey(symbol) { return `data_${symbol}`; }
function clearCache() { cache.clear(); document.getElementById("scanStats").innerText = "üßπ Cache cleared"; }

function logDebug(msg) {
    if (DEBUG_MODE) {
        console.log(msg);
        document.getElementById("debugLog").innerHTML += msg + "<br>";
    }
}

function toggleDebug() {
    DEBUG_MODE = !DEBUG_MODE;
    document.getElementById("debugBtn").innerText = `üêõ Debug: ${DEBUG_MODE ? 'ON' : 'OFF'}`;
    document.getElementById("debugLog").style.display = DEBUG_MODE ? 'block' : 'none';
}

function tpFromConfidence(score) {
    if (score >= 85) return { tp: 20, meaning: "High conviction" };
    if (score >= 75) return { tp: 15, meaning: "Strong setup" };
    return { tp: 10, meaning: "Safe-house trade" };
}

// ===== BTC GATE =====
async function fetchBTCGate() {
    try {
        const kRes = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&limit=2`);
        const tRes = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT`);
        const kText = await kRes.text();
        const tText = await tRes.text();
        if (isFakeResponse(kText) || isFakeResponse(tText)) throw new Error("Fake BTC data");
        const k = JSON.parse(kText);
        const ticker = JSON.parse(tText);
        const p = +k[0][4], c = +k[1][4];
        const ch = ((c - p) / p) * 100;
        const v1h = +k[1][7];
        const avgVol24h = (+ticker.quoteVolume) / 24;
        const vr = v1h / avgVol24h;
        btcGatePass = !(ch < BTC_GATE.maxDrop || ch > BTC_GATE.maxPump || vr > BTC_GATE.maxVol);
        document.getElementById("btcGateStatus").innerHTML = btcGatePass ?
            `<strong>‚úÖ BTC GATE OPEN</strong> (${ch.toFixed(2)}%, Vol ${vr.toFixed(1)}x)` :
            `<strong>‚ùå BTC BLOCKED</strong> (${ch.toFixed(2)}%, Vol ${vr.toFixed(1)}x)`;
    } catch (e) {
        console.error("BTC Gate error:", e);
        btcGatePass = true;
        document.getElementById("btcGateStatus").innerHTML = "‚ö†Ô∏è BTC GATE UNAVAILABLE";
    }
}

// ===== FETCH REAL DATA =====
async function fetchTickerWithEMA(symbol) {
    const cacheKey = getCacheKey(symbol);
    const now = Date.now();
    const cached = cache.get(cacheKey);
    if (cached && (now - cached.timestamp) < CACHE_TTL) return cached.data;

    try {
        const tUrl = `https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`;
        const kUrl = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=100`;
        const tRes = await fetch(tUrl);
        const kRes = await fetch(kUrl);
        const tText = await tRes.text();
        const kText = await kRes.text();

        if (isFakeResponse(tText) || isFakeResponse(kText)) {
            if (!FETCH_ERROR_LOG.has(symbol)) {
                logDebug(`‚ùå ${symbol}: Fake API response ‚Äî skipped`);
                FETCH_ERROR_LOG.add(symbol);
            }
            return null;
        }

        const ticker = JSON.parse(tText);
        const klines = JSON.parse(kText);
        if (klines.length < 99) return null;

        const closes = klines.map(k => +k[4]);
        const data = {
            price: +ticker.lastPrice,
            change: +ticker.priceChangePercent,
            vol: +ticker.quoteVolume,
            ema7: calculateEMA(closes, 7),
            ema25: calculateEMA(closes, 25),
            ema99: calculateEMA(closes, 99),
            prevClose: closes[closes.length - 2],
            closes: closes
        };

        cache.set(cacheKey, { data, timestamp: now });
        return data;
    } catch (e) {
        if (!FETCH_ERROR_LOG.has(symbol)) {
            logDebug(`‚ùå ${symbol}: ${e.message}`);
            FETCH_ERROR_LOG.add(symbol);
        }
        return null;
    }
}

// ===== BUILD SIGNAL =====
function buildSignal(symbol, d) {
    // STRICT EMA VALIDATION
    if (
        isNaN(d.ema7) || isNaN(d.ema25) || isNaN(d.ema99) ||
        d.ema7 <= d.ema25 ||
        d.ema25 <= d.ema99
    ) {
        return null;
    }

    if (CURRENT_MODE === "MOMENTUM") {
        if (d.change < 2 || d.change > 6 || d.vol < MIN_VOLUME_MOM) return null;
        const modeLabel = "MOMENTUM";
        const css = "momentum";
        const entry = Math.round(d.price * 0.98 * 1e8) / 1e8;
        const hold = "2‚Äì6h";
        const volWeight = Math.min(30, (d.vol / 5_000_000) * 10);
        const conf = Math.min(95, Math.round(40 + d.change * 8 + volWeight));
        if (conf < 70) return null;
        const tpObj = tpFromConfidence(conf);
        const status = "STATUS: TP ONLY üîπ";
        const decimals = d.price < 0.1 ? 8 : d.price < 1 ? 6 : 4;
        const html = `<div class="signal ${css}">
<span class="rank">‚≠ê ${conf}/100</span> | ${symbol.replace("USDT","")} ‚Äî ${modeLabel}
<br>${status}
<br><strong>TP:</strong> ${tpObj.tp}% ‚Äî ${tpObj.meaning}
<br>LIVE:  $${d.price.toFixed(decimals)}
<br>ENTRY: $${entry.toFixed(decimals)}
<br>HOLD:  ${hold}
</div>`;
        return { html, conf };
    } else { // DIP MODE
        if (d.change > -6 || d.vol < MIN_VOLUME_DIP) return null;
        if (Math.abs(d.change) > 30) return null;

        // MUST BE NEAR SUPPORT
        const distToEma99 = Math.abs((d.price - d.ema99) / d.ema99) * 100;
        if (distToEma99 > 2.0) return null;

        // üî• REBOUND CONFIRMED: price > previous close
        if (d.price <= d.prevClose) return null;

        const dipPct = Math.abs(d.change);
        const modeLabel = "DIP REVERSION";
        const css = dipPct < 12 ? "normal" : dipPct < 20 ? "flash" : "chaos";
        const entry = d.price; // ENTER AT LIVE PRICE
        const hold = "4‚Äì12h";
        let baseConf = 55 + (d.vol / 10_000_000) * 20;
        if (dipPct >= 8 && dipPct <= 18) baseConf += 15;
        const conf = Math.max(70, Math.min(95, Math.round(baseConf)));
        if (conf < 70) return null;
        const tpObj = tpFromConfidence(conf);
        const status = "‚úÖ REBOUND CONFIRMED ‚Äî ENTER NOW\nTRAIL AFTER +5% | TRAIL: 4%";
        const decimals = d.price < 0.1 ? 8 : d.price < 1 ? 6 : 4;
        const html = `<div class="signal ${css}">
<span class="rank">‚≠ê ${conf}/100</span> | ${symbol.replace("USDT","")} ‚Äî ${modeLabel}
<br>${status}
<br><strong>TP:</strong> ${tpObj.tp}% ‚Äî ${tpObj.meaning}
<br>LIVE:  $${d.price.toFixed(decimals)}
<br>ENTRY: $${entry.toFixed(decimals)}
<br>HOLD:  ${hold}
</div>`;
        return { html, conf };
    }
}

// ===== SCAN ENGINE =====
async function runScan() {
    const startTime = performance.now();
    const outputEl = document.getElementById("output");
    outputEl.innerHTML = "‚è≥ BTC Gate...";
    await fetchBTCGate();
    if (!btcGatePass) {
        outputEl.innerHTML = "<div class='stats'>‚ùå BTC Gate blocked</div>";
        return;
    }
    outputEl.innerHTML = "‚è≥ Scanning...";
    const signalObjects = [];
    for (let i = 0; i < FLASH_UNIVERSE.length; i += MAX_CONCURRENT) {
        const batch = FLASH_UNIVERSE.slice(i, i + MAX_CONCURRENT);
        const promises = batch.map(async (symbol) => {
            const data = await fetchTickerWithEMA(symbol);
            if (data) {
                const signal = buildSignal(symbol, data);
                if (signal) signalObjects.push(signal);
            }
        });
        await Promise.allSettled(promises);
        await new Promise(r => setTimeout(r, 300));
    }
    signalObjects.sort((a, b) => b.conf - a.conf);
    const htmlOutput = signalObjects.length === 0 ?
        "<div class='stats'>‚úÖ No signals (‚â•70 conf). Market quiet.</div>" :
        signalObjects.map(s => s.html).join("");
    outputEl.innerHTML = htmlOutput;
    const scanTime = ((performance.now() - startTime) / 1000).toFixed(1);
    document.getElementById("scanStats").innerText = `‚úÖ ${signalObjects.length} signals | ${scanTime}s | Cache: ${cache.size}/${FLASH_UNIVERSE.length}`;
}

// ===== MODE TOGGLE =====
function toggleMode() {
    CURRENT_MODE = CURRENT_MODE === "DIP" ? "MOMENTUM" : "DIP";
    document.getElementById("modeBtn").innerText = CURRENT_MODE === "DIP" ? "üìâ Mode: DIP" : "‚ö° Mode: MOMENTUM";
}
</script>
</body>
</html>
