<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Crypto Dip & MOMO-PULLBACK Scanner v9.6 Final</title>
<style>
body { font-family: monospace; background:#0f0f15; color:#eee; padding:20px; }
.signal { margin:12px 0; padding:10px; border-radius:6px; }
.flash { background:#2a1a3a; border-left:4px solid #ff6b6b; }
.normal { background:#1a2a2a; border-left:4px solid #4ecdc4; }
.momentum { background:#3a1a5a; border-left:4px solid #a678ff; }
.chaos { background:#1a0f1a; border-left:4px solid #ffcc00; }
.ob { border-left:4px solid #00ffcc; background:#0a2f2f !important; }
.rank { color:#ffcc00; font-weight:bold; }
button { background:#222; color:#ffcc00; border:1px solid #444; padding:6px 10px; margin-right:6px; cursor:pointer; }
</style>
</head>
<body>
<h2>üöÄ Crypto Dip & MOMO-PULLBACK Scanner v9.6 Final</h2>
<p>Confidence ‚â•75 | BTC 1h Gate | OB/FVG Auto-Adjust (¬±1.5%) | Pullback 0.8‚Äì1.5%</p>

<button onclick="runScan()">‚ñ∂ Run Scan</button>
<button onclick="toggleMode()" id="modeBtn">üìâ Mode: DIP</button>

<div id="btcGateStatus" style="margin-top:10px;"></div>
<div id="output" style="margin-top:20px;"></div>

<script>
/* ========= YOUR ORIGINAL COIN LISTS ‚Äî 100% PRESERVED ========= */
const FLASH_COINS = ["APTUSDT","SKYUSDT","TAOUSDT","JUPUSDT","ACTUSDT","CYBERUSDT","LUNAUSDT",
"SQDUSDT","MAGMAUSDT","PENDLEUSDT","MEMEUSDT","HYPEUSDT","TURBOUSDT","MYXUSDT","PIEVERSEUSDT"];
const NORMAL_COINS = ["INJUSDT","SOLUSDT","FETUSDT","ZENUSDT","AAVEUSDT","AVAXUSDT","ZROUSDT",
"ICPUSDT","LINKUSDT","PYTHUSDT","RENDERUSDT","SUIUSDT","DOTUSDT","ATOMUSDT",
"NEARUSDT","OPUSDT","ARBUSDT","RNDRUSDT","IMXUSDT","SEIUSDT","WLDUSDT",
"ORDIUSDT","PEPEUSDT","BONKUSDT","SHIBUSDT","DOGEUSDT","FLOKIUSDT",
"GALAUSDT","HOLOUSDT","PUMPUSDT","JTOUSDT","EIGENUSDT","NEIROETUSDT",
"BOMEUSDT","WIFUSDT","BUSDT","COAIUSDT"];
const ALL_COINS = [...new Set([...FLASH_COINS, ...NORMAL_COINS])];
const MIN_VOLUME_USD = 5_000_000;
let CURRENT_MODE = "DIP";

/* ========= BTC GATE ========= */
const BTC_GATE = { maxDrop: -1.2, maxPump: 1.5, maxVol: 2.0 };
let btcGatePass = true;
async function fetchBTCGate() {
  try {
    const k = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&limit=2`).then(r => r.json());
    const p = +k[0][4], c = +k[1][4];
    const ch = ((c - p) / p) * 100;
    const v1h = +k[1][7];
    const t = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT`).then(r => r.json());
    const avg = (+t.quoteVolume) / 24;
    const vr = v1h / avg;
    btcGatePass = !(ch < BTC_GATE.maxDrop || ch > BTC_GATE.maxPump || vr > BTC_GATE.maxVol);
    document.getElementById("btcGateStatus").innerHTML = btcGatePass ?
      `‚úÖ BTC PASS (${ch.toFixed(2)}%, Vol ${vr.toFixed(2)}x)` :
      `‚ùå BTC BLOCK (${ch.toFixed(2)}%, Vol ${vr.toFixed(2)}x)`;
  } catch {
    btcGatePass = true;
  }
}

/* ========= FETCH TICKER + EMA (1h) ========= */
async function fetchTickerWithEMA(symbol) {
  try {
    const tickerRes = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`);
    const ticker = await tickerRes.json();
    
    const klinesRes = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=100`);
    const klines = await klinesRes.json();
    
    if (klines.length < 99) return null;
    
    const closes = klines.map(k => parseFloat(k[4]));
    const ema7 = calculateEMA(closes, 7);
    const ema25 = calculateEMA(closes, 25);
    const ema99 = calculateEMA(closes, 99);
    
    return {
      price: parseFloat(ticker.lastPrice),
      change: parseFloat(ticker.priceChangePercent),
      vol: parseFloat(ticker.quoteVolume),
      low: parseFloat(ticker.lowPrice),
      high: parseFloat(ticker.highPrice),
      ema7: ema7,
      ema25: ema25,
      ema99: ema99
    };
  } catch (e) {
    return null;
  }
}

function calculateEMA(prices, period) {
  const k = 2 / (period + 1);
  let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
  for (let i = period; i < prices.length; i++) {
    ema = prices[i] * k + ema * (1 - k);
  }
  return ema;
}

/* ========= TOGGLE MODE ========= */
function toggleMode() {
  CURRENT_MODE = CURRENT_MODE === "DIP" ? "MOMENTUM" : "DIP";
  document.getElementById("modeBtn").innerText =
    CURRENT_MODE === "DIP" ? "üìâ Mode: DIP" : "‚ö° Mode: MOMENTUM";
}

/* ========= ORDER BLOCK / FVG DATA ========= */
const OB_FVG = {
  "SOLUSDT": [{ low: 127, high: 128.5 }, { low: 129.5, high: 131.5 }],
  "HOLOUSDT": [{ low: 0.077, high: 0.081 }],
  "FETUSDT": [{ low: 0.215, high: 0.22 }],
  "AAVEUSDT": [{ low: 150, high: 152 }],
  "AVAXUSDT": [{ low: 13, high: 13.5 }]
};

/* ========= CONFIDENCE SCORE ========= */
function confidenceScore(d, mode) {
  let score = 0;

  if (mode === "MOMENTUM") {
    if (d.change >= 4 && d.change <= 7) {
      if (d.change >= 6) score += 45;
      else score += 35;
    } else {
      return 0;
    }
  }

  if (mode === "DIP") {
    const dip = Math.abs(d.change);
    if (dip >= 8 && dip < 12) score += 25;
    else if (dip >= 12 && dip < 20) score += 35;
    else if (dip >= 20) score += 30;
  }

  if (d.vol >= 60_000_000) score += 30;
  else if (d.vol >= 40_000_000) score += 25;
  else if (d.vol >= 20_000_000) score += 20;
  else if (d.vol >= 5_000_000) score += 10;

  if (mode === "MOMENTUM") {
    const pullback = ((d.high - d.price) / d.high) * 100;
    if (pullback >= 0.8 && pullback <= 1.5) score += 15;
    else return 0;
  }

  if (mode === "MOMENTUM") {
    if (!(d.ema7 > d.ema25 && d.ema25 > d.ema99)) return 0;
    if (d.price < d.ema25) return 0;
  }

  return Math.min(100, Math.max(0, Math.round(score)));
}

/* ========= SIGNAL ENGINE ========= */
function buildSignal(symbol, d) {
  if (d.vol < MIN_VOLUME_USD) return null;

  let mode, css, entry, hold;

  if (CURRENT_MODE === "DIP") {
    if (d.change >= -8) return null;
    const dip = Math.abs(d.change);
    if (dip < 12) { mode = "NORMAL"; css = "normal"; }
    else if (dip < 20) { mode = "FLASH"; css = "flash"; }
    else { mode = "CHAOS"; css = "chaos"; }
    entry = d.price * (1 - 0.005);
    hold = "12‚Äì36h";
  }

  if (CURRENT_MODE === "MOMENTUM") {
    if (d.change < 4 || d.change > 7) return null;
    const pullback = ((d.high - d.price) / d.high) * 100;
    if (pullback < 0.8 || pullback > 1.5) return null;
    if (!(d.ema7 > d.ema25 && d.ema25 > d.ema99)) return null;
    if (d.price < d.ema25) return null;
    entry = d.price * (1 - pullback / 100 * 0.5);
    mode = "MOMO-PULLBACK";
    css = "momentum";
    hold = "4‚Äì12h";
  }

  const conf = confidenceScore(d, CURRENT_MODE);
  if (conf < 75) return null;

  // üîë FIXED TP LOGIC ‚Äî your rule, no over-rejection
  let tp;
  if (conf > 85 && d.vol >= 40_000_000) {
    tp = "12%";
  } else if (conf >= 75 && d.vol >= 20_000_000) {
    tp = "10%";
  } else {
    return null; // volume too low for reliable exit
  }

  // OB/FVG adjustment
  let obHighlight = false;
  if (OB_FVG[symbol]) {
    for (const z of OB_FVG[symbol]) {
      const zoneMid = (z.low + z.high) / 2;
      const entryDist = Math.abs(entry - zoneMid) / zoneMid;
      if (entryDist <= 0.015) {
        entry = Math.min(Math.max(entry, z.low), z.high);
        obHighlight = true;
        break;
      }
    }
  }

  // Formatting
  const priceDecimals = d.price < 0.1 ? 8 : d.price < 1 ? 6 : d.price < 10 ? 4 : 2;
  const entryDecimals = entry < 0.1 ? 8 : entry < 1 ? 6 : entry < 10 ? 4 : 2;
  const priceStr = d.price.toFixed(priceDecimals);
  const entryStr = entry.toFixed(entryDecimals);

  if (obHighlight) css += " ob";

  return {
    conf,
    html: `
<div class="signal ${css}">
<span class="rank">‚≠ê ${conf}/100</span> | ${symbol.replace("USDT", "")} ‚Äî ${mode}
<br>Price $${priceStr} | 24h ${d.change.toFixed(2)}%
<br>Entry $${entryStr} ‚Üí TP ${tp} | ${hold}
${obHighlight ? '<br><b>‚úÖ Adjusted to OB/FVG Zone</b>' : ''}
</div>`
  };
}

/* ========= RUN SCAN ========= */
async function runScan() {
  const out = document.getElementById("output");
  out.innerHTML = "‚è≥ BTC Gate...";
  await fetchBTCGate();
  if (!btcGatePass) {
    out.innerHTML += "<br>Scan blocked by BTC Gate";
    return;
  }

  let signals = [];
  for (const s of ALL_COINS) {
    const d = await fetchTickerWithEMA(s);
    if (d) {
      const sig = buildSignal(s, d);
      if (sig) signals.push(sig);
    }
  }

  signals = signals.filter(sig => sig.conf >= 75).sort((a, b) => b.conf - a.conf);
  if (signals.length === 0) {
    out.innerHTML = "<div>No high-confidence (‚â•75) signals found.</div>";
    return;
  }

  out.innerHTML = signals.map(s => s.html).join("");
}
</script>
</body>
</html>
