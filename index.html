<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>üöÄ FLASH SCANNER v11.7 ‚Äî 155 COINS</title>
<style>
body { font-family: monospace; background:#0f0f15; color:#eee; padding:20px; }
.signal { margin:12px 0; padding:12px; border-radius:6px; }
.flash { background:#2a1a3a; border-left:4px solid #ff6b6b; }
.normal { background:#1a2a2a; border-left:4px solid #4ecdc4; }
.momentum { background:#3a1a5a; border-left:4px solid #a678ff; }
.chaos { background:#1a0f1a; border-left:4px solid #ffcc00; }
.rank { color:#ffcc00; font-weight:bold; }
.status { font-weight:bold; margin-left:6px; }
button { background:#222; color:#ffcc00; border:1px solid #444; padding:10px 16px; margin-right:6px; cursor:pointer; font-weight:bold; }
.stats { background:#1a2a2a; padding:15px; border-radius:8px; margin:10px 0; }
</style>
</head>
<body>

<h2>üöÄ FLASH SCANNER v11.7 ‚Äî 155 COINS</h2>

<button onclick="runScan()">üîç RUN SCAN</button>
<button onclick="toggleMode()" id="modeBtn">üìâ Mode: DIP</button>
<button onclick="clearCache()">üßπ CLEAR CACHE</button>
<button onclick="toggleDebug()" id="debugBtn">üêõ Debug: OFF</button>

<div id="btcGateStatus" class="stats"></div>
<div id="scanStats" class="stats"></div>
<div id="debugLog" class="stats" style="display:none; background:#2a1a2a; font-size:0.8em;"></div>
<div id="output"></div>

<script>
// ===== CONFIG =====
const FLASH_UNIVERSE = [
"SOLUSDT","APTUSDT","INJUSDT","PUMPUSDT","SOMIUSDT","VIRTUALUSDT","SUIUSDT","DUSKUSDT",
"CLOUSDT","JOJOUSDT","BROCCOLI714USDT","WIFUSDT","RENDERUSDT","XRPUSDT","PEPEUSDT","PIPPINUSDT",
"TTDUSDT","BULLAUSDT","EULUSDT","SPELLUSDT","BOMEUSDT","TURBOUSDT","MOGUSDT","RAYUSDT",
"ORCAUSDT","MINAUSDT","QTUMUSDT","STXUSDT","PLUMEUSDT","IOTAUSDT","NEARUSDT","ARBUSDT","OPUSDT",
"FETUSDT","WLDUSDT","TAOUSDT","XPLUSDT","STGUSDT","PIXELUSDT","MAGICUSDT","1000SATSUSDT","BONKUSDT",
"LUNAUSDT","NILUSDT","TNSRUSDT","BATUSDT","HOOKUSDT","FLOKIUSDT","XAIUSDT","ZROUSDT","MTLUSDT",
"PYTHUSDT","JUPUSDT","GALAUSDT","SKLUSDT","WUSDT","PORTALUSDT","ZECUSDT","LUNCUSDT","AIOTUSDT",
"HYPERUSDT","GUSDT","TIAUSDT","TRBUSDT","ZILUSDT","PENGUUSDT","SEIUSDT","GUNUSDT","ZKUSDT","JASMYUSDT",
"BREVUSDT","HOMEUSDT","STORJUSDT","BANKUSDT","TRUUSDT","0GUSDT","EPICUSDT","HEMIUSDT","PNUTUSDT",
"ATUSDT","ZBTUSDT","AVNTUSDT","BIFIUSDT","FORMUSDT","ZRXUSDT","PROMUSDT","DOTUSDT","HOLOUSDT","IOUSDT",
"DYDXUSDT","WALUSDT","COOKIEUSDT","ACEUSDT","GIGGLEUSDT","TSTUSDT","RESOLVUSDT","DASHUSDT","FUNUSDT",
"IOSTUSDT","SFPUSDT","UNIUSDT","XTZUSDT","PROVEUSDT","RONINUSDT","MANAUSDT","BBUSDT","GPSUSDT",
"BANANAS31USDT","LUMIAUSDT","WOOUSDT"
];

const MIN_VOLUME_USD = 4_000_000; // DIP mode volume
let CURRENT_MODE = "DIP";
const BTC_GATE = { maxDrop: -1.5, maxPump: 2.0, maxVol: 3.0 };
let btcGatePass = true;
const cache = new Map(); 
const CACHE_TTL = 5*60*1000;
const MAX_CONCURRENT = 6;
let DEBUG_MODE = false;

// ===== UTILITIES =====
function calculateEMA(prices, period){
  if(prices.length < period) return 0;
  const k = 2/(period+1);
  let ema = prices.slice(0,period).reduce((a,b)=>a+b,0)/period;
  for(let i=period;i<prices.length;i++) ema = prices[i]*k + ema*(1-k);
  return ema;
}
function getCacheKey(symbol){ return `${symbol}_klines`; }
function clearCache(){ cache.clear(); document.getElementById("scanStats").innerText="üßπ Cache cleared"; }
function logDebug(msg){ if(DEBUG_MODE) console.log(msg); document.getElementById("debugLog").innerHTML += msg + "<br>"; }
function toggleDebug(){ DEBUG_MODE = !DEBUG_MODE; document.getElementById("debugBtn").innerText = `üêõ Debug: ${DEBUG_MODE?'ON':'OFF'}`; document.getElementById("debugLog").style.display = DEBUG_MODE?'block':'none'; }

// ===== RATE-LIMIT FETCH =====
async function rateLimitedFetch(url,retries=3){
  for(let i=0;i<retries;i++){
    try{
      const controller = new AbortController();
      const timeoutId = setTimeout(()=>controller.abort(),10000);
      const res = await fetch(url,{signal:controller.signal});
      clearTimeout(timeoutId);
      if(res.status===429){ await new Promise(r=>setTimeout(r,(i+1)*1500)); continue; }
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    }catch(e){
      if(i===retries-1) throw e;
      await new Promise(r=>setTimeout(r,1000*(i+1)));
    }
  }
}

// ===== BTC GATE =====
async function fetchBTCGate(){
  try{
    const k = await rateLimitedFetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1h&limit=2`);
    if(k.length < 2) throw new Error("Insufficient BTC data");
    
    const p = +k[0][4], c = +k[1][4];
    const ch = ((c-p)/p)*100;
    const v1h = +k[1][7];
    
    const ticker = await rateLimitedFetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT`);
    const avgVol24h = (+ticker.quoteVolume)/24;
    const vr = v1h / avgVol24h;
    
    btcGatePass = !(ch < BTC_GATE.maxDrop || ch > BTC_GATE.maxPump || vr > BTC_GATE.maxVol);
    
    document.getElementById("btcGateStatus").innerHTML = btcGatePass ? 
      `<strong>‚úÖ BTC GATE OPEN</strong> (${ch.toFixed(2)}%, Vol ${vr.toFixed(1)}x)` : 
      `<strong>‚ùå BTC BLOCKED</strong> (${ch.toFixed(2)}%, Vol ${vr.toFixed(1)}x)`;

  }catch(e){
    console.error("BTC Gate error:", e);
    btcGatePass = true;
    document.getElementById("btcGateStatus").innerHTML = "‚ö†Ô∏è BTC GATE UNAVAILABLE";
  }
}

// ===== FETCH TICKER + EMA =====
async function fetchTickerWithEMA(symbol){
  const cacheKey=getCacheKey(symbol), now=Date.now();
  const cached=cache.get(cacheKey);
  if(cached&&(now-cached.timestamp)<CACHE_TTL) return cached.data;
  try{
    const [ticker,klines]=await Promise.all([
      rateLimitedFetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`),
      rateLimitedFetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=100`)
    ]);
    if(klines.length<99) return null;
    const closes=klines.map(k=>+k[4]);
    const data={
      price:+ticker.lastPrice,
      change:+ticker.priceChangePercent,
      vol:+ticker.quoteVolume,
      low:+ticker.lowPrice,
      high:+ticker.highPrice,
      ema7:calculateEMA(closes,7),
      ema25:calculateEMA(closes,25),
      ema99:calculateEMA(closes,99),
      fetchedAt:now
    };
    cache.set(cacheKey,{data,timestamp:now});
    return data;
  }catch(e){ console.error(symbol,e); return null; }
}

// ===== CONFIDENCE =====
function confidenceScore(d,mode){
  let score=0;
  if(mode==="MOMENTUM"){ 
    if(!(d.change>=4 && d.change<=7)) return 0; 
    if(d.vol < 1_000_000) return 0;
    score+=d.change>=6?45:35; 
  } else { 
    const dip=Math.abs(d.change); 
    if(dip>=6&&dip<12) score+=30; 
    else if(dip>=12&&dip<20) score+=40; 
    else if(dip>=20) score+=45; 
    else return 0; 
  }
  if(d.vol>=60e6) score+=35; 
  else if(d.vol>=40e6) score+=30; 
  else if(d.vol>=20e6) score+=25; 
  else if(d.vol>=MIN_VOLUME_USD) score+=20; 
  else return 0;
  
  if(!(d.ema7 > d.ema99)) return 0;
  
  return Math.min(100,Math.round(score));
}

// ===== BUILD SIGNAL WITH TP/TRAIL STATUS =====
function buildSignal(symbol,d){
  if(d.vol<MIN_VOLUME_USD) return null;
  let modeLabel,css,entry,hold,statusLabel;
  if(CURRENT_MODE==="DIP"){
    if(d.change>=-6) return null;
    modeLabel="DIP REVERSION";
    const dipPct=Math.abs(d.change);
    css=dipPct<12?"normal":dipPct<20?"flash":"chaos";
    entry=d.price*0.995;
    hold="12‚Äì36h";
    const conf=confidenceScore(d,CURRENT_MODE);
    if(conf<70) return null;
    statusLabel=conf>=82 ? "üî∫ TRAIL ACTIVE" : "üîπ TP ONLY";
  } else { // MOMENTUM
    if(!(d.change>=4&&d.change<=7)) return null;
    const pullback = ((d.high - d.price)/d.high)*100;
    if(pullback<0.5 || pullback>2.0) return null;
    modeLabel="CONTINUATION";
    css="momentum";
    entry=d.price*(1 - pullback/100*0.5);
    hold="4‚Äì12h";
    statusLabel="üîπ TP ONLY";
    const conf=confidenceScore(d,CURRENT_MODE);
    if(conf<70) return null;
  }
  
  let conf=confidenceScore(d,CURRENT_MODE);
  let armPct=CURRENT_MODE==="DIP"?5:4;
  let trailPct=CURRENT_MODE==="DIP"?6:5;
  let trailHtml="";
  
  if(CURRENT_MODE==="DIP" && statusLabel==="üî∫ TRAIL ACTIVE"){
    const armPrice=entry*(1+armPct/100);
    const lockMin=entry*1.02;
    const lockMax=entry*1.04;
    trailHtml=`ü™Ç AUTO-TRAIL:
‚Ä¢ Arm +${armPct}% ‚Üí $${armPrice.toFixed(8)}
‚Ä¢ Trail ${trailPct}% 
‚Ä¢ Lock +2‚Äì4% ‚Üí $${lockMin.toFixed(8)}‚Äì$${lockMax.toFixed(8)}`;
  } else {
    const tpPct = Math.max(0.10,Math.abs(d.change)/100); // minimum 10% TP
    const tpPrice = entry*(1+tpPct);
    trailHtml=`üíé FIXED TP ${Math.round(tpPct*100)}% ‚Üí $${tpPrice.toFixed(8)}`;
  }

  const decimals=d.price<0.1?8:d.price<1?6:4;
  return {
    conf,
    html:`<div class="signal ${css}">
<span class="rank">‚≠ê ${conf}/100</span> | ${symbol.replace("USDT","")} ‚Äî ${modeLabel} <span class="status">${statusLabel}</span>
<br><strong>LIVE:</strong> $${d.price.toFixed(decimals)}
<br><strong>ENTRY:</strong> $${entry.toFixed(decimals)}
<br><strong>HOLD:</strong> ${hold}
<br>${trailHtml}
</div>`
  };
}

// ===== RUN SCAN =====
async function runScan(){
  const startTime=performance.now();
  const outputEl=document.getElementById("output");
  outputEl.innerHTML="‚è≥ BTC Gate...";
  await fetchBTCGate();
  if(!btcGatePass){ outputEl.innerHTML="<div class='stats'>‚ùå BTC Gate blocked</div>"; return; }
  outputEl.innerHTML="‚è≥ Scanning...";
  const signals=[];
  for(let i=0;i<FLASH_UNIVERSE.length;i+=MAX_CONCURRENT){
    const batch=FLASH_UNIVERSE.slice(i,i+MAX_CONCURRENT);
    const batchPromises=batch.map(async symbol=>{
      const data=await fetchTickerWithEMA(symbol);
      if(data){
        const signal=buildSignal(symbol,data);
        if(signal) signals.push(signal);
      }
    });
    await Promise.allSettled(batchPromises);
    await new Promise(r=>setTimeout(r,200));
  }
  signals.sort((a,b)=>b.conf-a.conf);
  outputEl.innerHTML=signals.length===0? "<div class='stats'>‚úÖ No signals (‚â•70 conf). Market quiet.</div>" : signals.map(s=>s.html).join("");
  const scanTime = ((performance.now()-startTime)/1000).toFixed(1);
  document.getElementById("scanStats").innerText=`‚úÖ ${signals.length} signals | ${scanTime}s | Cache: ${cache.size}/${FLASH_UNIVERSE.length}`;
}

// ===== MODE TOGGLE =====
function toggleMode(){
  CURRENT_MODE=CURRENT_MODE==="DIP"?"MOMENTUM":"DIP";
  document.getElementById("modeBtn").innerText=CURRENT_MODE==="DIP"?"üìâ Mode: DIP":"‚ö° Mode: MOMENTUM";
}
</script>
</body>
</html>
