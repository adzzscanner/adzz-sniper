<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>Adzz Sniper ‚Äî FINAL v3</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { 
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', monospace; 
  background: #0b0b16; 
  color: #0af; 
  padding: 8px; 
  line-height: 1.4; 
  overflow-x: hidden;
}
h1 { 
  color: #0f0; 
  text-align: center; 
  font-size: 1.25em; 
  margin: 6px 0;
}
.container { max-width: 100%; margin: 0 auto; padding: 0 4px; }
.status { 
  background: #1a1a2e; 
  padding: 8px; 
  border-radius: 6px; 
  text-align: center; 
  margin: 10px 0; 
  font-size: 0.95em;
  color: #ffaa00;
}
.section { 
  background: #16213e; 
  padding: 10px; 
  margin: 10px 0; 
  border-radius: 6px; 
  font-size: 0.95em;
}
.chaos { border-left: 4px solid #ff5555; }
.flash { border-left: 4px solid #4488ff; }
.normal { border-left: 4px solid #0f0; }
.coin-row { 
  padding: 10px; 
  margin: 6px 0; 
  background: #0d0d1a; 
  border-radius: 6px; 
  font-size: 1.15em; 
  word-break: break-all;
}
.tp-levels { font-size: 1.05em; color: #88f; margin-top: 4px; }
.tp-main { color: #0f0; font-weight: bold; }
.high-conviction { color: #ffff00; font-weight: bold; }
.volatility-score { font-size: 0.85em; color: #aaa; margin-top: 4px; }
.button-container { text-align: center; margin: 15px 0; }
button { 
  padding: 12px 24px; 
  background: #0f0; 
  color: #000; 
  border: none; 
  font-weight: bold; 
  border-radius: 6px; 
  font-size: 1.1em; 
  cursor: pointer; 
  width: 100%;
  max-width: 300px;
  margin: 0 auto;
}
.dom-btn {
  background: #444;
  color: #0af;
  border: 1px solid #0af;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 0.85em;
  cursor: pointer;
  margin-top: 6px;
}
.dom-btn:hover { background: #555; }
.manual-note { 
  background: #2a0a3a; 
  padding: 10px; 
  border-left: 4px solid #ff55ff; 
  margin: 15px 0; 
  font-size: 0.95em; 
  text-align: center;
  border-radius: 6px;
}
</style>
</head>
<body>
<div class="container">
  <h1>Adzz Sniper ‚Äî FINAL v3</h1>
  <div class="status" id="status">Tap "SCAN" to find 10‚Äì20% setups</div>

  <div class="manual-note">
    üü¢ 8‚Äì12% ‚Üí 10% TP ‚Ä¢ üü¶ 12‚Äì20% ‚Üí 15%/10% ‚Ä¢ üî¥ 20‚Äì70% ‚Üí 20%/15%<br>
    Tap "CallCheck DOM" to confirm liquidity before entering
  </div>

  <div class="section normal">
    <h3>üü¢ NORMAL: 8‚Äì12% dips ‚Üí 10% TP</h3>
    <div id="normalOutput">No setups</div>
  </div>

  <div class="section flash">
    <h3>üü¶ FLASH: >12‚Äì20% dips ‚Üí 15% (strong) / 10% (weak)</h3>
    <div id="flashOutput">No setups</div>
  </div>

  <div class="section chaos">
    <h3>üî¥ CHAOS: >20‚Äì70% dips ‚Üí 20% (strong) / 15% (weak)</h3>
    <div id="chaosOutput">No setups</div>
  </div>

  <div class="button-container">
    <button onclick="startScan()">SCAN</button>
  </div>
</div>

<script>
// ‚úÖ FINAL COIN UNIVERSE ‚Äî EXCLUSIVE TIERS
const NORMAL_COINS = ["JUP","PYTH","PIXEL","TNSR","STG","HOOK","MAGIC","ZRO","PORTAL","NIL","ONDO","W","INJ","TAO","FET","RENDER","SEI","SUI"];
const FLASH_COINS = ["APT","ARB","OP","IMX","TIA","NEAR","MATIC","LINK","RNDR","XPL","POWER"];
const CHAOS_COINS = ["BEAT","TRU","KAITO","ONT","TRADOOR","STABLE","SKY","FLOW"];
const ALL_COINS = [...NORMAL_COINS, ...FLASH_COINS, ...CHAOS_COINS];

const BASE_URL = "https://api.binance.com/api/v3";

// Fetch with retry
async function fetchWithRetry(url, retries = 2, timeoutMs = 8000) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch(url, { signal: controller.signal });
    clearTimeout(timeout);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  } catch (e) {
    clearTimeout(timeout);
    if (retries > 0) {
      await new Promise(r => setTimeout(r, 500));
      return fetchWithRetry(url, retries - 1, timeoutMs);
    }
    return null;
  }
}

async function fetchKlines(symbol, interval, limit) {
  return await fetchWithRetry(`${BASE_URL}/klines?symbol=${symbol}USDT&interval=${interval}&limit=${limit}`);
}

async function getBTCRange(interval, limit) {
  const klines = await fetchKlines("BTC", interval, limit);
  if (!klines || klines.length === 0) return 0;
  const highs = klines.map(k => parseFloat(k[2]));
  const lows = klines.map(k => parseFloat(k[3]));
  const high = Math.max(...highs);
  const low = Math.min(...lows);
  return ((high - low) / low) * 100;
}

function calculateRSI(prices, period = 6) {
  if (prices.length < period + 1) return 50;
  let gains = 0, losses = 0;
  for (let i = prices.length - period; i < prices.length; i++) {
    const diff = prices[i] - prices[i - 1];
    if (diff > 0) gains += diff;
    else losses -= diff;
  }
  if (losses === 0) return 100;
  if (gains === 0) return 0;
  const rs = gains / losses;
  return 100 - (100 / (1 + rs));
}

function calculateVolatilityScore(drop, volSpike, price) {
  let priceMultiplier = 1.0;
  if (price < 0.5) priceMultiplier = 1.8;
  else if (price < 1.0) priceMultiplier = 1.5;
  else if (price < 2.0) priceMultiplier = 1.2;
  else if (price > 5.0) priceMultiplier = 0.7;
  return drop * Math.min(volSpike, 3.0) * priceMultiplier;
}

function calculateEMA(prices, period) {
  const k = 2 / (period + 1);
  let ema = prices[0];
  for (let i = 1; i < prices.length; i++) {
    ema = prices[i]*k + ema*(1-k);
  }
  return ema;
}

function isNearLow(lows, price, pct=2) {
  const minLow = Math.min(...lows);
  return price <= minLow*(1 + pct/100);
}

function calculateDrop(highs, currentPrice) {
  const recentHigh = Math.max(...highs);
  return recentHigh>0 ? ((recentHigh-currentPrice)/recentHigh)*100 : 0;
}

function isFakeVolume(high, low, close, volume) {
  const priceRangePct = ((high - low) / close) * 100;
  const minRange = (close < 1) ? 1.5 : 1.0;
  return volume > 100_000 && priceRangePct < minRange;
}

function renderCoinRow(data) {
  const { coin, zone, price, tp, highConv, volatilityScore } = data;

  // üî• DYNAMIC ENTRY RANGE BY MODE
  let entryLow = price * 0.99;
  let entryHigh = price * 1.01;
  if (zone === 'Chaos') {
    entryLow = price * 0.97;   // 3% below
    entryHigh = price * 1.02;  // 2% above
  }
  entryLow = entryLow.toFixed(4);
  entryHigh = entryHigh.toFixed(4);

  const icons = { Normal: 'üü¢', Flash: 'üü¶', Chaos: 'üî¥' };
  const badge = highConv ? ' <span class="high-conviction">üî•</span>' : '';
  const speedBadge = volatilityScore >= 50 ? ' ‚ö°' : '';

  const tpPct = ((tp / price) - 1) * 100;
  let tpLabel;
  if (zone === 'Normal') tpLabel = '10%';
  else if (zone === 'Flash') tpLabel = tpPct >= 14.5 ? '15%' : '10%';
  else tpLabel = tpPct >= 19.5 ? '20%' : '15%';

  return `
    <div class="coin-row">
      ${icons[zone]} ${coin}${badge}${speedBadge} ‚Äî $${price.toFixed(4)}<br>
      <span class="tp-levels">Entry: $${entryLow} ‚Äì $${entryHigh} | TP <span class="tp-main">$${tp.toFixed(4)}</span> (${tpLabel})</span>
      <div class="volatility-score">Volatility: ${volatilityScore.toFixed(1)}</div>
      <div style="text-align:center;margin-top:8px;">
        <button class="dom-btn" onclick="checkDOM('${coin}')">CallCheck DOM</button>
        <span id="dom-${coin}" style="margin-left:8px;font-size:0.9em;"></span>
      </div>
    </div>
  `;
}

async function detectZone(coin, btc24hRange) {
  let mode = null;
  if (NORMAL_COINS.includes(coin)) mode = 'Normal';
  else if (FLASH_COINS.includes(coin)) mode = 'Flash';
  else if (CHAOS_COINS.includes(coin)) mode = 'Chaos';
  else return null;

  const interval = (mode === 'Chaos') ? '4h' : '1h';
  const limit = (mode === 'Chaos') ? 50 : 25;
  const klines = await fetchKlines(coin, interval, limit);
  if (!klines || klines.length < limit) return null;

  const highs = klines.map(k=>parseFloat(k[2]));
  const lows = klines.map(k=>parseFloat(k[3]));
  const closes = klines.map(k=>parseFloat(k[4]));
  const vols = klines.map(k=>parseFloat(k[5]));
  const price = closes[closes.length-1];
  const drop = calculateDrop(highs, price);

  let valid = false;
  if (mode === 'Normal' && drop >= 8 && drop <= 12) valid = true;
  else if (mode === 'Flash' && drop > 12 && drop <= 20) valid = true;
  else if (mode === 'Chaos' && drop > 20 && drop <= 70) valid = true;
  if (!valid) return null;

  const lastCandle = klines[klines.length - 1];
  const high = parseFloat(lastCandle[2]);
  const low = parseFloat(lastCandle[3]);
  const close = parseFloat(lastCandle[4]);
  const volume = parseFloat(lastCandle[5]);

  if (isFakeVolume(high, low, close, volume)) return null;

  const lastHigh = high;
  const lastLow = low;
  if ((lastHigh - lastLow) / price < 0.015) return null;

  const ema7 = calculateEMA(closes.slice(-7), 7);
  const ema25 = calculateEMA(closes.slice(-25), 25);
  const nearLow = isNearLow(lows.slice(-6), price, 4);
  const vol24 = vols.slice(-24).reduce((a,b)=>a+b,0);

  const minVol = (price < 0.1) ? 10_000_000 :
                 (price < 1)   ? 5_000_000  : 2_000_000;
  if (vol24 < minVol) return null;

  const volAvg24 = vols.slice(-25,-1).reduce((a,b)=>a+b,0)/24;
  const volSpike = volAvg24 > 0 ? vols[vols.length-1] / volAvg24 : 1.0;

  if (mode === 'Normal') {
    if (ema7 < ema25 && nearLow) {
      const volatilityScore = calculateVolatilityScore(drop, volSpike, price);
      return { zone: 'Normal', coin, price, tp: price * 1.10, highConv: true, volatilityScore };
    }
  }
  else if (mode === 'Flash') {
    if (btc24hRange >= 2 && btc24hRange <= 6 && volSpike >= 1.5 && ema7 <= ema25 * 1.01 && nearLow) {
      const volatilityScore = calculateVolatilityScore(drop, volSpike, price);
      const tp = volatilityScore >= 50 ? price * 1.15 : price * 1.10;
      return { zone: 'Flash', coin, price, tp, highConv: volatilityScore >= 50, volatilityScore };
    }
  }
  else if (mode === 'Chaos') {
    if (ema7 < ema25 && nearLow && volSpike >= 1.3) {
      const rsi6 = calculateRSI(closes, 6);
      if (rsi6 >= 20) return null;
      const volatilityScore = calculateVolatilityScore(drop, volSpike, price);
      const tp = volatilityScore >= 60 ? price * 1.20 : price * 1.15;
      return { zone: 'Chaos', coin, price, tp, highConv: volatilityScore >= 60, volatilityScore };
    }
  }

  return null;
}

function renderZoneSection(zoneId, results) {
  const outputEl = document.getElementById(`${zoneId}Output`);
  if (results.length > 0) {
    results.sort((a,b) => b.volatilityScore - a.volatilityScore);
    const maxShow = zoneId === 'chaos' ? 1 : (zoneId === 'flash' ? 2 : 5);
    outputEl.innerHTML = results.slice(0, maxShow).map(renderCoinRow).join('');
  } else {
    outputEl.innerHTML = `<div class="status">No setups</div>`;
  }
}

async function checkDOM(coin) {
  const statusEl = document.getElementById(`dom-${coin}`);
  statusEl.innerHTML = "üîç";
  
  try {
    const res = await fetch(`https://api.binance.com/api/v3/depth?symbol=${coin}USDT&limit=20`);
    if (!res.ok) throw new Error("DOM fetch failed");
    const data = await res.json();
    
    const bids = data.bids.slice(0,5).map(b => [parseFloat(b[0]), parseFloat(b[1])]);
    const asks = data.asks.slice(0,5).map(a => [parseFloat(a[0]), parseFloat(a[1])]);
    
    const bidUSDT = bids.reduce((sum, b) => sum + b[0]*b[1], 0);
    const askUSDT = asks.reduce((sum, a) => sum + a[0]*a[1], 0);
    const ratio = bidUSDT / askUSDT;
    
    let mode = 'Normal';
    if (CHAOS_COINS.includes(coin)) mode = 'Chaos';
    else if (FLASH_COINS.includes(coin)) mode = 'Flash';
    
    const minRatio = (mode === 'Chaos') ? 1.2 : (mode === 'Flash') ? 1.1 : 1.0;
    
    if (ratio >= minRatio) {
      statusEl.innerHTML = `‚úÖ OK (${ratio.toFixed(1)})`;
      statusEl.style.color = "#0f0";
    } else {
      statusEl.innerHTML = `‚ùå Weak (${ratio.toFixed(1)})`;
      statusEl.style.color = "#ff5555";
    }
  } catch (e) {
    statusEl.innerHTML = "‚ö†Ô∏è Error";
    statusEl.style.color = "#ffaa00";
  }
}

async function startScan() {
  const status = document.getElementById('status');
  status.innerHTML = "üîÑ Checking BTC regime...";

  const [btc48h, btc24h] = await Promise.all([
    getBTCRange('4h', 25),
    getBTCRange('1h', 25)
  ]);

  const btcStable = btc48h < 8;
  const flashSafe = btcStable && btc24h >= 2 && btc24h <= 6;
  const flashText = flashSafe ? 'üü¢ Flash-Safe' : '‚ö™ Flash-Locked';

  if (!btcStable) {
    status.innerHTML = `<span style="color:#ff5555;font-weight:bold;">üî¥ BTC volatile ‚Äî NO TRADE</span>`;
    ['normal','flash','chaos'].forEach(id => {
      document.getElementById(`${id}Output`).innerHTML = '<div class="status">Market not tradeable</div>';
    });
    return;
  }

  status.innerHTML = `üü¢ BTC: ${btc48h.toFixed(1)}% ‚Ä¢ ${flashText}<br>Scanning ${ALL_COINS.length} coins...`;

  const normalResults = [];
  const flashResults = [];
  const chaosResults = [];

  for (let i = 0; i < ALL_COINS.length; i++) {
    const coin = ALL_COINS[i];
    status.innerHTML = `üü¢ BTC: ${btc48h.toFixed(1)}% ‚Ä¢ ${flashText}<br>Scanning ${coin}...`;
    const signal = await detectZone(coin, btc24h);
    if (signal) {
      if (signal.zone === 'Normal') normalResults.push(signal);
      else if (signal.zone === 'Flash') flashResults.push(signal);
      else if (signal.zone === 'Chaos') chaosResults.push(signal);
    }
    if (i % 5 === 0) await new Promise(r => setTimeout(r, 100));
  }

  renderZoneSection('normal', normalResults);
  renderZoneSection('flash', flashResults);
  renderZoneSection('chaos', chaosResults);

  const total = normalResults.length + flashResults.length + chaosResults.length;
  status.innerHTML = `üü¢ BTC: ${btc48h.toFixed(1)}% ‚Ä¢ ${flashText}<br><strong>${total} setup${total !== 1 ? 's' : ''} ready</strong>`;
}
</script>
</body>
</html>
