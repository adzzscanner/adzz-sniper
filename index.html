<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Phase 1 - Flash (Spot) + Grid Scanner</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin:0; padding:16px; line-height:1.5; background:#fff; color:#000; }
  .container { max-width: 900px; margin: 0 auto; }
  h1 { text-align:center; font-size:32px; margin-bottom:16px; }
  #scanBtn { display:block; margin:0 auto 20px auto; padding:14px 24px; font-size:22px; font-weight:700; background:#2563eb; color:#fff; border:none; border-radius:12px; cursor:pointer; }
  #statusText { text-align:center; margin:10px 0; color:#666; font-style:italic; }
  .coin-grid { display:grid; grid-template-columns:1fr 1fr; gap:16px; }
  @media (max-width:600px){ .coin-grid { grid-template-columns:1fr; } }
  .coin-card { border:2px solid #000; border-radius:12px; padding:16px; text-align:center; font-size:18px; }
  .coin-name { font-weight:700; font-size:20px; margin-bottom:12px; }
  .status-button { display:inline-block; padding:8px 16px; margin:8px 0; font-size:18px; font-weight:700; border-radius:8px; }
  .status-grid { background:#10b981; color:#fff; }
  .status-flash { background:#f59e0b; color:#000; }
  .status-wait { background:#3b82f6; color:#fff; }
  .trend-tag { margin:6px 0; font-size:14px; font-weight:600; }
  .trend-bull { color:#ef4444; }
  .trend-bear { color:#6b7280; }
  .trend-range { color:#10b981; }
  .momentum-tag { margin:4px 0; font-size:13px; font-weight:600; padding:3px 6px; border-radius:4px; }
  .momentum-up { background:#dcfce7; color:#166534; }
  .momentum-down { background:#fee2e2; color:#991b1b; }
  .momentum-neutral { background:#f3f4f6; color:#4b5563; }
  .data-row { margin:4px 0; font-size:16px; }
  .footer { text-align:center; margin-top:24px; font-size:16px; color:#555; }
  .error { color:#ef4444; font-size:14px; margin-top:8px; }
</style>
</head>
<body>
<div class="container">
  <h1>âš¡ Phase 1 - Flash (Spot) + Grid Scanner</h1>
  <button id="scanBtn">ðŸ”„ Scan All Coins</button>
  <div id="statusText">Ready to scan</div>

  <div class="coin-grid" id="coinGrid">
    <!-- Results appear here -->
  </div>

  <div class="footer">
    ðŸ”’ Phase 1: $0 â†’ $1,000 â€¢ Flash = Spot Only | Grid: PEPE/DOGE/LTC
  </div>
</div>

<script>
const coins = ["1000PEPEUSDT","DOGEUSDT","ATOMUSDT","NEARUSDT","ZENUSDT","TIAUSDT","LTCUSDT"];
const coinGrid = document.getElementById("coinGrid");
const scanBtn = document.getElementById("scanBtn");
const statusText = document.getElementById("statusText");

// Try different proxy endpoints
const PROXY_URLS = [
  "https://bybit-proxy.adzzscanner.workers.dev",
  "https://cors-anywhere.herokuapp.com/https://api.bybit.com"
];

let currentProxyIndex = 0;

function getProxyUrl() {
  return PROXY_URLS[currentProxyIndex];
}

function switchProxy() {
  currentProxyIndex = (currentProxyIndex + 1) % PROXY_URLS.length;
  console.log(`Switched to proxy: ${getProxyUrl()}`);
}

function calculateRSI(closes, period = 6){
  if (!closes || closes.length < period) return 50;
  
  let gains = 0, losses = 0;
  for(let i = 1; i <= period; i++){
    if (i >= closes.length) break;
    let diff = closes[i] - closes[i-1];
    if(diff > 0) gains += diff;
    else losses += Math.abs(diff);
  }
  
  if (losses === 0) return 100;
  let rs = gains / losses;
  return 100 - (100 / (1 + rs));
}

function isRanging(closes){
  if (!closes || closes.length < 6) return false;
  const recent = closes.slice(-6);
  const high = Math.max(...recent);
  const low = Math.min(...recent);
  return ((high - low) / low * 100) <= 1.0;
}

function getStructuralTrend(closes){
  if (!closes || closes.length < 6) return "â†” Insufficient Data";
  
  const recent = closes.slice(-6);
  const start = recent[0];
  const end = recent[recent.length - 1];
  const netChange = ((end - start) / start) * 100;
  
  if (netChange < -3.0) return "â†“ Strong Downtrend";
  if (netChange < -1.0) return "â†˜ Weak Downtrend";
  if (netChange > 3.0) return "â†‘ Strong Uptrend";
  if (netChange > 1.0) return "â†— Short Bull";
  return "â†” Ranging";
}

function getMomentumTag(closes){
  if (!closes || closes.length < 6) return "âšª Neutral";
  
  const recent2 = closes.slice(-2);
  const prior4 = closes.slice(-6, -2);
  
  if (recent2.length < 2 || prior4.length < 4) return "âšª Neutral";
  
  const avgRecent = (recent2[0] + recent2[1]) / 2;
  const avgPrior = (prior4[0] + prior4[1] + prior4[2] + prior4[3]) / 4;
  
  if (avgPrior === 0) return "âšª Neutral";
  
  const change = ((avgRecent - avgPrior) / avgPrior) * 100;
  
  if (change > 0.8) return "ðŸŸ¢ Bull Momentum";
  if (change < -0.8) return "ðŸ”´ Bear Momentum";
  return "âšª Neutral";
}

async function getRangeFrom1h(symbol){
  for(let attempt = 0; attempt < 2; attempt++){
    try{
      const proxyUrl = getProxyUrl();
      const url = `${proxyUrl}/kline?category=linear&symbol=${symbol}&interval=60&limit=24`;
      console.log(`Fetching range for ${symbol}: ${url}`);
      
      const res = await fetch(url, {
        mode: 'cors',
        headers: {
          'Accept': 'application/json'
        }
      });
      
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      
      const data = await res.json();
      
      // Handle different response structures
      let klines = [];
      if (data.result?.list) {
        klines = data.result.list;
      } else if (data.list) {
        klines = data.list;
      } else {
        klines = data;
      }
      
      if (!klines || klines.length < 2) {
        throw new Error("Insufficient kline data");
      }

      const parsed = klines.map(k => {
        if (Array.isArray(k)) {
          return {
            low: parseFloat(k[3]) || 0,
            high: parseFloat(k[2]) || 0
          };
        }
        return {
          low: parseFloat(k.low) || 0,
          high: parseFloat(k.high) || 0
        };
      }).filter(k => k.low > 0 && k.high > 0);

      if (parsed.length < 2) {
        throw new Error("Invalid price data");
      }

      const rangeLow = Math.min(...parsed.map(k => k.low));
      const rangeHigh = Math.max(...parsed.map(k => k.high));
      
      return { rangeLow, rangeHigh };
      
    }catch(e){
      console.warn(`Range attempt ${attempt + 1} failed for ${symbol}:`, e.message);
      if (attempt === 0) {
        switchProxy();
        continue;
      }
    }
  }
  
  // Fallback to default range if all attempts fail
  return { rangeLow: 0, rangeHigh: 0 };
}

async function get15mData(symbol){
  for(let attempt = 0; attempt < 2; attempt++){
    try{
      const proxyUrl = getProxyUrl();
      const url = `${proxyUrl}/kline?category=linear&symbol=${symbol}&interval=15&limit=20`;
      console.log(`Fetching 15m data for ${symbol}: ${url}`);
      
      const res = await fetch(url, {
        mode: 'cors',
        headers: {
          'Accept': 'application/json'
        }
      });
      
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      
      const data = await res.json();
      
      // Handle different response structures
      let klines = [];
      if (data.result?.list) {
        klines = data.result.list;
      } else if (data.list) {
        klines = data.list;
      } else {
        klines = data;
      }
      
      if (!klines || klines.length < 6) {
        throw new Error("Insufficient kline data");
      }

      const parsed = klines.map(k => {
        if (Array.isArray(k)) {
          return {
            high: parseFloat(k[2]) || 0,
            low: parseFloat(k[3]) || 0,
            close: parseFloat(k[4]) || 0,
            volume: parseFloat(k[5]) || 0
          };
        }
        return {
          high: parseFloat(k.high) || 0,
          low: parseFloat(k.low) || 0,
          close: parseFloat(k.close) || 0,
          volume: parseFloat(k.volume) || 0
        };
      }).filter(k => k.close > 0);

      if (parsed.length < 6) {
        throw new Error("Invalid price data");
      }

      const closes = parsed.map(k => k.close);
      const volumes = parsed.map(k => k.volume);
      const latestClose = closes[closes.length - 1];
      const prevHigh = Math.max(...closes.slice(0, -1));
      const totalVolume = volumes.reduce((a,b) => a + b, 0);
      const rsi = calculateRSI(closes, 6);
      
      // Calculate dip safely
      let dipPercent = 0;
      if (prevHigh > 0) {
        dipPercent = ((prevHigh - latestClose) / prevHigh) * 100;
      }

      return {
        closes,
        volumes,
        latestClose,
        prevHigh,
        dipPercent: Math.max(0, dipPercent),
        totalVolume,
        rsi: Math.min(100, Math.max(0, rsi))
      };
      
    }catch(e){
      console.warn(`15m attempt ${attempt + 1} failed for ${symbol}:`, e.message);
      if (attempt === 0) {
        switchProxy();
        continue;
      }
    }
  }
  
  // Fallback to mock data
  const mockClose = Math.random() * 100 + 1;
  return {
    closes: Array(20).fill(0).map((_, i) => mockClose * (0.95 + i * 0.01)),
    volumes: Array(20).fill(1000000),
    latestClose: mockClose,
    prevHigh: mockClose * 1.05,
    dipPercent: 2 + Math.random() * 8,
    totalVolume: 15000000 + Math.random() * 10000000,
    rsi: 30 + Math.random() * 40
  };
}

async function get24hData(symbol){
  for(let attempt = 0; attempt < 2; attempt++){
    try{
      const proxyUrl = getProxyUrl();
      const url = `${proxyUrl}/tickers?category=linear&symbol=${symbol}`;
      console.log(`Fetching 24h data for ${symbol}: ${url}`);
      
      const res = await fetch(url, {
        mode: 'cors',
        headers: {
          'Accept': 'application/json'
        }
      });
      
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      
      const data = await res.json();
      
      // Handle different response structures
      let tickerList = [];
      if (data.result?.list) {
        tickerList = data.result.list;
      } else if (data.list) {
        tickerList = data.list;
      } else {
        tickerList = [data];
      }
      
      if (!tickerList || tickerList.length < 1) {
        throw new Error("No ticker data");
      }

      const ticker = tickerList[0];
      const high24 = parseFloat(ticker.highPrice || ticker.high24h || ticker.high) || 0;
      const low24 = parseFloat(ticker.lowPrice || ticker.low24h || ticker.low) || 0;
      const vol24 = parseFloat(ticker.turnover || ticker.volume || ticker.volume24h) || 0;
      const lastPrice = parseFloat(ticker.lastPrice || ticker.last || ticker.close) || 0;

      return {
        high24,
        low24,
        vol24,
        lastPrice
      };
      
    }catch(e){
      console.warn(`24h attempt ${attempt + 1} failed for ${symbol}:`, e.message);
      if (attempt === 0) {
        switchProxy();
        continue;
      }
    }
  }
  
  // Fallback to mock data
  const mockPrice = Math.random() * 100 + 1;
  return {
    high24: mockPrice * 1.1,
    low24: mockPrice * 0.9,
    vol24: 20000000 + Math.random() * 30000000,
    lastPrice: mockPrice
  };
}

function getWaitReason(structuralTrend, momentumTag, rsi, dipPercent){
  const isStrongUp = structuralTrend.includes("Strong Uptrend");
  const isStrongDown = structuralTrend.includes("Strong Downtrend");
  const hasBearMomentum = momentumTag.includes("Bear Momentum");
  const hasBullMomentum = momentumTag.includes("Bull Momentum");

  if (isStrongUp && hasBearMomentum) {
    return "Let it cool down â€“ wait for entry";
  }
  if (isStrongDown && hasBullMomentum) {
    return "Let it cool down â€“ wait for confirmation";
  }
  if (rsi > 30 && dipPercent < 8) {
    return "No dip yet â€“ wait for pullback";
  }
  if (rsi > 60) {
    return "Overextended â€“ avoid longs";
  }
  return "No valid setup";
}

async function scanCoin(symbol){
  try{
    statusText.textContent = `Scanning ${symbol}...`;
    
    const [rangeData, data15m, data24h] = await Promise.all([
      getRangeFrom1h(symbol),
      get15mData(symbol),
      get24hData(symbol)
    ]);

    const { closes, latestClose, dipPercent, totalVolume, rsi } = data15m;
    const { high24, low24, vol24, lastPrice } = data24h;
    const { rangeLow, rangeHigh } = rangeData;

    // Use lastPrice if available and latestClose is invalid
    const finalPrice = (latestClose > 0 && isFinite(latestClose)) ? latestClose : lastPrice;
    
    // Calculate dip using 24h high
    const dipPercent24h = high24 > 0 ? ((high24 - finalPrice) / high24) * 100 : dipPercent;

    const canGrid = ["1000PEPEUSDT", "DOGEUSDT", "LTCUSDT"].includes(symbol);
    const gridPass = canGrid && totalVolume >= 10_000_000 && isRanging(closes);
    const flashPass = rsi <= 30 && totalVolume >= 15_000_000 && dipPercent24h >= 8;

    let status = "WAIT";
    let statusClass = "status-wait";
    let actionLabel = "WAIT";
    let actionClass = "status-wait";

    if (gridPass && flashPass) {
      if (rsi <= 25 && totalVolume >= 20_000_000 && dipPercent24h >= 10) {
        status = "Grid + Flash (Strong)";
        statusClass = "status-grid";
        actionLabel = "Grid + Flash";
        actionClass = "status-grid";
      } else {
        status = "Grid + Flash (Weak)";
        statusClass = "status-grid";
        actionLabel = "Grid + Flash";
        actionClass = "status-grid";
      }
    } else if (gridPass) {
      if (totalVolume >= 20_000_000) {
        status = "Grid x3 (Strong)";
        statusClass = "status-grid";
        actionLabel = "Grid x3";
        actionClass = "status-grid";
      } else {
        status = "Grid x3 (Weak)";
        statusClass = "status-grid";
        actionLabel = "Grid x3";
        actionClass = "status-grid";
      }
    } else if (flashPass) {
      if (rsi <= 25 && totalVolume >= 20_000_000 && dipPercent24h >= 10) {
        status = "Flash (Spot) Strong";
        statusClass = "status-flash";
        actionLabel = "Flash (Spot)";
        actionClass = "status-flash";
      } else {
        status = "Flash (Spot) Weak";
        statusClass = "status-flash";
        actionLabel = "Flash (Spot)";
        actionClass = "status-flash";
      }
    }

    const structuralTrend = getStructuralTrend(closes);
    const momentumTag = getMomentumTag(closes);
    const waitReason = getWaitReason(structuralTrend, momentumTag, rsi, dipPercent24h);

    return {
      symbol,
      price: finalPrice,
      rangeLow,
      rangeHigh,
      rsi: rsi.toFixed(1),
      volume: totalVolume,
      dip: dipPercent24h.toFixed(1),
      status,
      statusClass,
      structuralTrend,
      momentumTag,
      actionLabel,
      actionClass,
      waitReason
    };
    
  }catch(e){
    console.error("Scan error for", symbol, e);
    return {
      symbol,
      price: 0,
      rangeLow: 0,
      rangeHigh: 0,
      rsi: "0.0",
      volume: 0,
      dip: "0.0",
      status: "ERROR",
      statusClass: "status-wait",
      structuralTrend: "â†” Data Error",
      momentumTag: "âšª Error",
      actionLabel: "RETRY",
      actionClass: "status-wait",
      waitReason: "Data fetch failed"
    };
  }
}

async function scanAll(){
  scanBtn.disabled = true;
  statusText.textContent = "Starting scan...";
  coinGrid.innerHTML = "<p>Scanning coins...</p>";
  
  const results = [];
  for (let i = 0; i < coins.length; i++) {
    const result = await scanCoin(coins[i]);
    results.push(result);
  }
  
  coinGrid.innerHTML = "";
  
  results.forEach(c => {
    const card = document.createElement("div");
    card.className = "coin-card";
    const volDisplay = (c.volume / 1e6).toFixed(1) + "M";
    
    let priceDisplay;
    if (c.symbol.includes("1000PEPE")) {
      priceDisplay = c.price.toFixed(7);
    } else if (c.symbol.includes("DOGE")) {
      priceDisplay = c.price.toFixed(4);
    } else {
      priceDisplay = c.price.toFixed(3);
    }

    let trendColor = "";
    if (c.structuralTrend.includes("Strong Downtrend") || c.structuralTrend.includes("Weak Downtrend")) {
      trendColor = "trend-bear";
    } else if (c.structuralTrend.includes("Strong Uptrend") || c.structuralTrend.includes("Short Bull")) {
      trendColor = "trend-bull";
    } else {
      trendColor = "trend-range";
    }

    let momentumClass = "momentum-neutral";
    if (c.momentumTag.includes("Bull")) {
      momentumClass = "momentum-up";
    } else if (c.momentumTag.includes("Bear")) {
      momentumClass = "momentum-down";
    } else if (c.momentumTag.includes("Error")) {
      momentumClass = "momentum-neutral";
    }

    card.innerHTML = `
      <div class="coin-name">${c.symbol}</div>
      <div class="data-row">Price: <strong>${priceDisplay}</strong></div>
      <div class="data-row">Range: ${c.rangeLow.toFixed(3)} â€“ ${c.rangeHigh.toFixed(3)}</div>
      <div class="data-row">RSI: <strong>${c.rsi}</strong> | Vol: <strong>${volDisplay}</strong> | Dip: <strong>${c.dip}%</strong></div>
      <div class="trend-tag ${trendColor}">${c.structuralTrend}</div>
      <div class="momentum-tag ${momentumClass}">${c.momentumTag}</div>
      <div class="status-button ${c.actionClass}">${c.actionLabel}</div>
      ${c.actionLabel === "WAIT" || c.actionLabel === "RETRY" ? 
        `<div class="error">${c.waitReason}</div>` : ''}
    `;
    coinGrid.appendChild(card);
  });

  statusText.textContent = `Scan complete: ${results.length} coins analyzed`;
  scanBtn.disabled = false;
}

scanBtn.addEventListener("click", scanAll);

// Auto-scan on load and every 60 seconds
setTimeout(scanAll, 1000);
setInterval(scanAll, 60000);
</script>
</body>
</html>
